#+HUGO_SECTION: posts
#+HUGO_BASE_DIR: ../
#+author: Nick Forrer

* Hello
** Hello World
:PROPERTIES:
:EXPORT_FILE_NAME: hello-world
:EXPORT_DATE: 2019-06-23
:END:
Testing the site
* Tutorials :@tutorials:
** DONE Roguelike tutorial for Common Lisp - Part 0 - Setup :roguelike:gamedev:lisp:tutorial:
CLOSED: [2019-06-23 Sun 10:24]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part0
:END:
This set of tutorials is going to follow the [[http://rogueliketutorials.com/tutorials/tcod/][Python TCOD tutorial]], but will be
written in Common Lisp and use the BearLibTerminal library.

*** Prior Knowledge
This tutorial assumes you are familiar with programming in Common Lisp. If
you're not familiar, I would highly recommend checking out [[http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/][A Road to Common Lisp]]
on Steve Losh's blog. It provides many valuable resources to get up to speed
with Common Lisp, and is how I got started.
*** Installation
You will need the following installed:
- A Common Lisp implementation. I will be using and testing my code against
  [[http://www.sbcl.org/][SBCL]].
- [[https://www.quicklisp.org/beta/][Quicklisp]]
- An editor. I use Emacs, with the [[https://github.com/hlissner/doom-emacs][Doom Emacs]] configuration.

I run Linux (Fedora) on my machine, and SBCL is available in the default
repositories. If it is not available in your distro (or if you're not running
Linux), check out the [[http://www.sbcl.org/getting.html][getting started]] page.

Quicklisp should be configured based on the installation guide on their [[https://www.quicklisp.org/beta/][home page]].

For the Emacs configuration, the most important peice is to have a REPL
available. I use the [[https://github.com/joaotavora/sly][sly]] package, although [[https://common-lisp.net/project/slime/][SLIME]] is popular as well. Having a
REPL running in your editor makes the development process much more efficient
and enjoyable.

*** Project setup
Once you have everything installed that you need, you can get the project
skeleton created, with the needed dependencies. Since you have Quicklisp
installed, it will be easy to generate a project skeleton using [[https://www.xach.com/lisp/quickproject/][Quickproject]].

First, open emacs and start your REPL (if you're using sly, the Emacs command is
just M-x "sly"). In the REPL:

#+BEGIN_SRC common-lisp
(ql:quickload :quickproject)
(quickproject:make-project #p"cl-rltut" :depends-on '(:cl-blt))
#+END_SRC

That should create a "cl-rltut" directory within the current working
directory of your REPL (this can be shown for sly with the "sly-pwd" command,
and changed with the "sly-cd" command). Within the project directory, you should
see an ASDF file named "cl-rltut.asd", which looks like the following:
#+BEGIN_SRC common-lisp
(asdf:defsystem #:cl-rltut
  :description "Describe cl-rltut here"
  :author "Nick Forrer"
  :license  "MIT"
  :version "0.0.1"
  :serial t
  :depends-on (#:cl-blt)
  :components ((:file "package")
               (:file "cl-rltut")))
#+END_SRC

You will also need to download the cl-blt package, which contains the
Common Lisp bindings for BearLibTerminal. The reason for this is because
cl-blt is not currently available in an online repository that
Quicklisp could download it automatically. Download the package using:

#+BEGIN_SRC sh
git clone https://github.com/sjl/cl-blt.git ~/quicklisp/local-projects/cl-blt
#+END_SRC

That will clone the cl-blt Git repo into a directory that Quicklisp will look at
when trying to load an ASDF system.

In addition to the Common Lisp bindings, you will also need the BearLibTerminal
library itself. Download the appropriate binary for your system from
http://foo.wyrd.name/en:bearlibterminal#download. Once downloaded, extract the
archive and find the shared library dependency. For the Linux archive, this will
be Linux64/libBearLibTerminal.so (assuming you are using a 64-bit OS). This file
should be placed in a "lib" directory in the root of your project.

To make it easier to load your project from the REPL, you can create a symlink
in the local-projects directly that points to your project, so that Quicklisp
can always find it (use the correct path to your project instead of ~/src/lisp/cl-rltut):

#+BEGIN_SRC sh
ln -s ~/src/lisp/cl-rltut ~/quicklisp/local-projects
#+END_SRC

With all of that in place, you should now be able to load your projects system
in the REPL to ensure in can find all the dependencies with:

#+BEGIN_SRC common-lisp
(ql:quickload :cl-rltut)
#+END_SRC

Assuming you don't see any errors, then your project is all set to continue with
the tutorial! To see what the project should look like at this point, you can
find the current state for Part 0 here: https://github.com/nwforrer/cl-rltut/tree/part-0.

*** Questions and Feedback
If you run into any issues, or have some feedback, feel free to email me at:
nwforrer AT gmail.com.

Continue to the [[/posts/roguelike-tutorial-part1][next tutorial]].

** DONE Roguelike tutorial for Common Lisp - Part 1 - Drawing the player :roguelike:gamedev:lisp:tutorial:
CLOSED: [2019-06-25 Tue 20:10]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part1
:END:
Welcome to the first part of the tutorial! If you haven't already, please check
out [[/posts/roguelike-tutorial-part0][Part 0]] to get the project created.

This tutorial series is based on the [[http://rogueliketutorials.com][Python Roguelike Tutorial]]. This will be
covering [[http://rogueliketutorials.com/tutorials/tcod/part-1/][Part 1]] of that tutorial as closely as possible, with the exception of
different structure to support more idiomatic Common Lisp, and with using
BearLibTerminal instead of tcod.

*** Opening a window
First we'll work on getting a window created. The Common Lisp bindings we're
using for BearLibTerminal provide some higher level functions to make
interacting with the library more "lispy", so some of the function names won't
align exactly with what you'll see in the BearLibTerminal documentation
(although you can also call those methods, we'll mostly use the high level
functions). You can find the documentation for the high-level API here:
https://sjl.bitbucket.io/cl-blt/reference/.

Open up emacs, and start your REPL. Load your project and change
into your package:

#+BEGIN_SRC common-lisp
(ql:quickload :cl-rltut)
(in-package :cl-rltut)
#+END_SRC

Now in the cl-rltut.lisp file, create a main function to open the window, set
some configs, and enter into a loop:

#+BEGIN_SRC common-lisp
(defparameter *screen-width* 80)
(defparameter *screen-height* 50)

(defun draw ()
  (blt:clear)
  (blt:refresh))

(defun config ()
  (blt:set "window.resizeable = true")
  (blt:set "window.size = ~Ax~A" *screen-width* *screen-height*)
  (blt:set "window.title = Roguelike"))

(defun main()
  (blt:with-terminal
    (config)
    (loop :do
      (draw)
      (blt:key-case (blt:read)
                    (:escape (return))
                    (:close (return))))))
#+END_SRC

If you evaluate the buffer with `sly-eval-buffer`, you will be able to run the
game from your REPL with:
#+BEGIN_SRC common-lisp
(main)
#+END_SRC

If everything was done correctly, you
should see an empty window:

[[/cl-rltut/empty-window.png]]

Exciting! Let's step through the code to see what's going on.

#+BEGIN_SRC common-lisp
(defparameter *screen-width* 80)
(defparameter *screen-height* 50)
#+END_SRC

This creates two global variables to store the width and height of the window,
in cells. By default, the size of the cell is selected based on the font size.

#+BEGIN_SRC common-lisp
(blt:with-terminal ... )
#+END_SRC

This is a macro that wraps the terminal_open and terminal_close functions of the
underlying library. The macro will open a terminal at the start, execute
whatever code we pass within the call, and then close the terminal.

#+BEGIN_SRC common-lisp
(defun config ()
  (blt:set "window.resizeable = true")
  (blt:set "window.size = ~Ax~A" *screen-width* *screen-height*)
  (blt:set "window.title = Roguelike"))
#+END_SRC

The `set` function is how you configure various library options, such as
managing fonts, or setting window settings like we do here. The nice thing about
the Common Lisp wrapper is that it allows the use of format directives to format
the string. We take advantage of that when setting the window.size property to
the width and height variables that we defined earlier. If you're not familiar
with Common Lisp format directives, you can read more about them here: http://www.gigamonkeys.com/book/a-few-format-recipes.html.

#+BEGIN_SRC common-lisp
(loop :do ... )
#+END_SRC

This just starts up an endless loop that our game will run in.

#+BEGIN_SRC common-lisp
(blt:key-case (blt:read)
              (:escape (return))
              (:close (return)))
#+END_SRC

`key-case` is another macro defined in the high level API of the Common Lisp
bindings. This is used to handle keyboard input. As the first parameter, it
takes in an event from the keyboard. We're using the `read` function to get
this data. If there are no events in the input queue, `read` will wait for an
event to come. This blocking behaviour is perfect for our case, because it will
make the turn-based gameplay easier.
The second parameter to the `key-case` macro is a list of clauses. The first
part of a clause, for example :escape, will match with the event returned from
the `read` call. If the event is that the escape button was pressed, then the
second part of the clause wil be executed. In that case, we just return from the
main function to close the program. Only the code in a matching clause will be executed.

#+BEGIN_SRC common-lisp
(defun draw ()
  (blt:clear)
  (blt:refresh))
#+END_SRC

Here we just have a placeholder draw function, which will clear the window to
black and then call `refresh`. All of the drawing that BearLibTerminal does is
to an off-screen buffer, so we won't see our changes displayed until the
`refresh` function is called. While we aren't actually drawing anything yet,
this is needed to make the window visible. BearLibTerminal will only display the
window with the first `refresh` call after opening the window. Prior to that,
the window will stay invisible.

*** Adding the player
Now that we have a window, let's get the player drawn to the screen. Update the
draw function to look like this:

#+BEGIN_SRC common-lisp
(defun draw()
  (blt:clear)
  (setf (blt:color) (blt:white)
        (blt:cell-char 10 10) #\@)
  (blt:refresh))
#+END_SRC

Pretty easy! When blt:color is set, that color will be used for all subsequent
drawing until the color is changed again. Then, we set the cell at 10x10 to the
@ character. If all works, you should see this when you run the game:

[[/cl-rltut/drawing-player.png]]

Next we'll want to be able to move the player around. We're already capturing
some keyboard input, so it won't be difficult to capture the arrow keys as well.
Then we just need to have a way to track the players position so that we can
update it when an arrow key is pressed. Make updates to the following functions:

#+BEGIN_SRC common-lisp
(defun draw (player-x player-y)
  (blt:clear)
  (setf (blt:color) (blt:white)
        (blt:cell-char player-x player-y) #\@)
  (blt:refresh))

(defun handle-keys ()
  (let ((action nil))
    (blt:key-case (blt:read)
                  (:up (setf action (list :move (cons 0 -1))))
                  (:down (setf action (list :move (cons 0 1))))
                  (:left (setf action (list :move (cons -1 0))))
                  (:right (setf action (list :move (cons 1 0))))
                  (:escape (setf action (list :quit t)))
                  (:close (setf action (list :quit t))))
    action))

(defun main()
  (blt:with-terminal
    (config)
    (loop :with player-x = (/ *screen-width* 2)
          :and player-y = (/ *screen-height* 2)
          :do
             (draw player-x player-y)
             (let* ((action (handle-keys))
                    (move (getf action :move))
                    (exit (getf action :quit)))
               (if exit
                   (return))
               (when move
                 (incf player-x (car move))
                 (incf player-y (cdr move)))))))
#+END_SRC

If you run the game now, you should be able to move the player around using the
arrow keys.

We created a new "handle-keys" function, and moved the input handling code into
it. handle-keys returns a property list. When one of the arrow keys is pressed,
the function would return something like:
#+BEGIN_SRC common-lisp
'(:move (0 . 1))
#+END_SRC

When looking at the return value, we can check what type of action is returned
with:
#+BEGIN_SRC common-lisp
(getf action :move)
#+END_SRC

If we run that on the previous example, the result would be the (0 . 1), telling
us that there was a move action to increment the player-y by 1. We can get the x
and y portion of that with the car and cdr functions respectively. If there was no
move action, getf would return nil.

We also added player-x and player-y as local variables on the loop. This will be
changed in the future to add some more structure, but works for now.

*** Conclusion
That's going to be it for this tutorial. You can find the current state of the
code on [[https://github.com/nwforrer/cl-rltut/tree/part-1][Github]]. The list of changes since the previous tutorial can be found at
https://github.com/nwforrer/cl-rltut/compare/part-0...part-1.

Continue to the [[/posts/roguelike-tutorial-part2][part 2]].
** DONE Roguelike tutorial for Common Lisp - Part 2 - Generic entity and map :roguelike::gamedev:lisp:tutorial:
CLOSED: [2019-06-27 Thu 21:53]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part2
:END:
This tutorial series is based on the [[http://rogueliketutorials.com][Python Roguelike Tutorial]]. This will be
covering [[http://rogueliketutorials.com/tutorials/tcod/part-2/][Part 2]] of that tutorial.

It's time to start thinking about how we want to structure our entities, and
what the map will look like. We will be creating a generic entity class that all
entities in the game will use, and introduce the concept of how the map will be
structured. We'll be using classes and generic methods provided with CLOS here.
If you're unfamiliar with CLOS, there is a good overview in [[https://lispcookbook.github.io/cl-cookbook/clos.html][The Common Lisp Cookbook]].

*** Generic entity
The first thing we'll be doing is creating a class to represent entities in the
game, storing it's position, color, and character to render.
#+BEGIN_SRC common-lisp
(defclass entity ()
  ((x :initarg :x :accessor entity/x)
   (y :initarg :y :accessor entity/y)
   (char :initarg :char :accessor entity/char)
   (color :initarg :color :accessor entity/color)))
#+END_SRC

Next we can create some methods on that class to handle drawing and moving the
entity.
#+BEGIN_SRC common-lisp
(defmethod move ((e entity) dx dy)
  (incf (entity/x e) dx)
  (incf (entity/y e) dy))

(defmethod draw ((e entity))
  (with-slots (x y char color) e
    (setf (blt:color) color
          (blt:cell-char x y) char)))
#+END_SRC

We'll rename our old draw function to render-all, and from there call the entities draw
method for each entity.
#+BEGIN_SRC common-lisp
(defun render-all (entities)
  (blt:clear)
  (mapc #'draw entities)
  (blt:refresh))
#+END_SRC
We're just mapping the draw method call over the list of all entities passed
into the function.

Now we actually need to create some entities. Update the main function as
follows:
#+BEGIN_SRC common-lisp
(defun main()
  (blt:with-terminal
    (config)
    (loop :with player = (make-instance 'entity
                                        :x (/ *screen-width* 2)
                                        :y (/ *screen-height* 2)
                                        :char #\@
                                        :color (blt:white))
          :and npc = (make-instance 'entity
                                    :x (- (/ *screen-width* 2) 5)
                                    :y (/ *screen-height* 2)
                                    :char #\@
                                    :color (blt:yellow))
          :with entities = (list player npc)
          :do
             (render-all entities)
             (let* ((action (handle-keys))
                    (move (getf action :move))
                    (exit (getf action :quit)))
               (when exit
                 (return))
               (when move
                 (move player (car move) (cdr move)))))))
#+END_SRC
Here we removed the player-x and player-y variables, and instead create a player
entity. We have also added an npc entity to show how we can use the entity class
for more than just the player. We add those two entities to an entities list,
which gets passed to the render-all function. We also call the new move method
on the player entity when a move action is requested.

If you run the game now, it should look like the following:
[[/cl-rltut/generic-entity-class.png]]

The NPC should look like a yellow @ symbol, and player movement should work like it
did before.

*** Creating the map
Now that we can create and render entities, we should create a map for them to
move around in. We're not going to procedurally generate the map yet (that will
be in the next tutorial), but we'll create the structure needed to render the
map.

Before we do, let's create a new file to store the map related code, as it can
become pretty large once we're generating it. Create a file named
"game-map.lisp" in the root of your project, and declare that it's in the same
package by placing this at the top of the file:
#+BEGIN_SRC common-lisp
(in-package #:cl-rltut)
#+END_SRC

You also need to update the ASDF file to include the new file in your system:
#+BEGIN_SRC common-lisp
(asdf:defsystem #:cl-rltut
  :description "Describe cl-rltut here"
  :author "Nick Forrer"
  :license "MIT"
  :version "0.0.1"
  :serial t
  :depends-on (#:cl-blt)
  :components ((:file "package")
               (:file "cl-rltut")
               (:file "game-map")))
#+END_SRC

In the "game-map.lisp" file, create a new tile class.
#+BEGIN_SRC common-lisp
(defclass tile ()
  ((blocked :initarg :blocked
            :accessor tile/blocked
            :initform nil)
   (block-sight :initarg :block-sight
                :accessor tile/block-sight
                :initform nil)))

(defmethod initialize-instance :after ((tile tile) &rest initargs)
  (declare (ignore initargs))
  (with-slots (blocked block-sight) tile
    (if (null block-sight)
        (setf block-sight blocked))))
#+END_SRC

The blocked slot will indicate whether this tile will block movement, such as if
it represents a wall. The block-sight slot will indicate if this tile will block
an entities vision. These are separate so that we can support things like lava
tiles, where we don't want an entity to walk through it, but they can see past
it. We will implement field-of-vision later, but that will determine which tiles
the player can see at a given time.
We've also defined an after method for initialize-instance for the tile class.
This will be called after a make-instance is called for the class, and the slots
are initialized. Here, we want to make sure the block-sight slot is set to true
if blocked is also true.

Now lets create a game-map class, which will hold a 2D array of tiles to make up
our map.
#+BEGIN_SRC common-lisp
(defclass game-map ()
  ((width :initarg :w :accessor game-map/w)
   (height :initarg :h :accessor game-map/h)
   (tiles :accessor game-map/tiles)))

(defmethod initialize-instance :after ((map game-map) &rest initargs)
  (declare (ignore initargs))
  (setf (game-map/tiles map) (make-array (list (game-map/w map) (game-map/h map)))))
#+END_SRC

We also define an initialize-instance method for game-map. This initializes the
tiles slot to an array with WxH dimensions.

Next create a function to initialize the tiles in the array.
#+BEGIN_SRC common-lisp
(defun initialize-tiles ((map game-map))
  (dotimes (y (game-map/h map))
    (dotimes (x (game-map/w map))
      (setf (aref (game-map/tiles map) x y) (make-instance 'tile))))

  (setf (tile/blocked (aref (game-map/tiles map) 30 22)) t)
  (setf (tile/block-sight (aref (game-map/tiles map) 30 22)) t)
  (setf (tile/blocked (aref (game-map/tiles map) 31 22)) t)
  (setf (tile/block-sight (aref (game-map/tiles map) 31 22)) t)
  (setf (tile/blocked (aref (game-map/tiles map) 32 22)) t)
  (setf (tile/block-sight (aref (game-map/tiles map) 32 22)) t))
#+END_SRC
This loops through all the tiles in the map, and initializes them to a new
instance of the tile class. This will create all the tiles with blocked and
block-sight set to nil. We then set 3 of the tiles to have blocked and
block-sight set to true so we can test it.

We now have a map created, but we can't see it yet. Back in the "cl-rltut.lisp"
file, update the render-all function to take the map as a parameter and render
all it's tiles.
#+BEGIN_SRC common-lisp
(defparameter *color-map* (list :dark-wall (blt:rgba 0 0 100)
                                :dark-ground (blt:rgba 50 50 150)))

(defun render-all (entities map)
  (blt:clear)
  (dotimes (y (game-map/h map))
    (dotimes (x (game-map/w map))
      (let* ((tile (aref (game-map/tiles map) x y))
             (wall (tile/blocked tile)))
        (if wall
            (setf (blt:background-color) (getf *color-map* :dark-wall))
            (setf (blt:background-color) (getf *color-map* :dark-ground))))
      (setf (blt:cell-char x y) #\Space)))

  (mapc #'draw entities)

  (setf (blt:background-color) (blt:black))
  (blt:refresh))
#+END_SRC

We first declare a color-map global variable as a property list to hold a
mapping of keys (like "dark-wall") to their BearLibTerminal color value. This
just makes it easier to reference colors, and easy to update them later if we
wanted to. Then, in the render-all method, we loop over all of the tiles in the
map. We check if the blocked slot is true, and if so, set blt:background-color
to dark-wall. Whenever you set the background-color, all subsequent draw calls
will use it as the background in the cell you draw to. If the tile is not
blocked, we set background-color to dark-ground. We then draw an empty space at
the tiles cell, which will just populate the background of the cell.
After the entire map and all entities are drawn, we reset the background-color
to black.

Now in the main function, lets create a map instance and pass it to the
render-all function to actually see it displayed.
#+BEGIN_SRC common-lisp
(defparameter *map-width* 80)
(defparameter *map-height* 45)

(defparameter *map* nil)

(defun main ()
  (blt:with-terminal
    (config)
    (setf *map* (make-instance 'game-map :w *map-width* :h *map-height*))
    (initialize-tiles *map*)
    (loop :with player = (make-instance 'entity
                                        :x (/ *screen-width* 2)
                                        :y (/ *screen-height* 2)
                                        :char #\@
                                        :color (blt:white))
          :and npc = (make-instance 'entity
                                    :x (- (/ *screen-width* 2) 5)
                                    :y (/ *screen-height* 2)
                                    :char #\@
                                    :color (blt:yellow))
          :with entities = (list player npc)
          :do
             (render-all entities *map*)
             (let* ((action (handle-keys))
                    (move (getf action :move))
                    (exit (getf action :quit)))
               (when exit
                 (return))
               (when move
                 (move player (car move) (cdr move)))))))
#+END_SRC

We create two global variables to hold the map width and height (in cells). The
height is set to 5 cells smaller than the height of the window. This is so that
there is some blank space at the bottom of the window to be used for messages,
which we'll get to in a later tutorial. We also declare the map variable as a
global. This isn't really necessary, and could easily be created as a local
variable in the main function. The reason I've declared it global is so that it
can be looked at and manipulated in the REPL. It's up to you whether you find
that useful enough to make the variable global.
The changes to the main method are straight forward. We initialize an instance
of the game-map class, and initialize it's tiles. Then we just pass it along to
the render-all method to have it displayed.

If you run the game now, it should look like this:
[[/cl-rltut/initial-map-render.png]]

The three dark tiles are the walls. You'll notice that you can still walk
through them, which isn't correct. We can easily fix that by first adding a
helper method in the "game-map-lisp" file:
#+BEGIN_SRC common-lisp
(defmethod blocked-p ((map game-map) x y)
  (tile/blocked (aref (game-map/tiles map) x y)))
#+END_SRC
This takes in the map and an x,y coordinate, and returns whether that tile is
blocked.

We then just need to call that with the coordinates we're moving to, and if it's
blocked, don't move the player. Update the `(when move)` block in the main
function like:
#+BEGIN_SRC common-lisp
(when move
  (unless (blocked-p *map*
                     (+ (entity/x player) (car move))
                     (+ (entity/y player) (cdr move)))
    (move player (car move) (cdr move))))
#+END_SRC

Now if you run the game, it should block you from walking through the walls!

*** Conclusion
That's all for this tutorial. Next we'll be working on procedurally generating
the dungeon map!

You can find the current state of the code on [[https://github.com/nwforrer/cl-rltut/tree/part-2][Github]]. The list of changes since
the previous tutorial can be found at
https://github.com/nwforrer/cl-rltut/compare/part-1...part-2.

Continue to the [[/posts/roguelike-tutorial-part3][part 3]].
** DONE Roguelike tutorial for Common Lisp - Part 3 - Generating a dungeon :roguelike::gamedev:lisp:tutorial:
CLOSED: [2019-07-05 Fri 17:05]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part3
:END:
This tutorial series is based on the [[http://rogueliketutorials.com][Python Roguelike Tutorial]]. This will be
covering [[http://rogueliketutorials.com/tutorials/tcod/part-3/][Part 3]] of that tutorial.

In this post, we'll be procedurally generating the dungeon! We will generate
randomly sized rooms, and connect them with tunnels for the player and npcs to
walk around.

*** Looping over tiles
First things first, we're going to set all tiles to blocked by default.
Previously, we had all tiles set as floors, and placed a couple of walls to
test. Most dungeon generation algorithms work in the opposite way. They first
block all tiles, and then procedurally carve out rooms and corridors.

Update the initialize-tiles method to match the following:
#+BEGIN_SRC common-lisp
(defmethod initialize-tiles ((map game-map))
  (dotimes (y (game-map/h map))
    (dotimes (x (game-map/w map))
      (setf (aref (game-map/tiles map) x y) (make-instance 'tile :blocked t)))))
#+END_SRC

Looping over tiles like this is going to be something that happens a few times.
To make this easier, we can define a macro that will loop over all tiles (or a
subsection of tiles), and assign the current tile to a variable for us to use.
The macro looks like this:

#+BEGIN_SRC common-lisp
(defmacro map-tiles-loop ((map tile-val &key (row-val (gensym)) (col-val (gensym)) (x-start 0) (y-start 0) (x-end nil) (y-end nil)) &body body)
  `(loop :for ,col-val :from ,x-start :below (if (null ,x-end) (game-map/w ,map) ,x-end)
         :do
            (loop :for ,row-val :from ,y-start :below (if (null ,y-end) (game-map/h ,map) ,y-end)
                  :do
                     (let ((,tile-val (aref (game-map/tiles ,map) ,col-val ,row-val)))
                       (declare (ignorable ,tile-val))
                       ,@body))))
#+END_SRC

The macro takes in a map with all the tiles initialized, a tile-val which holds
the name you want to use for the variable that holds the current tile. It also
takes in some optional parameters via keys: row-val and col-val represent the
names of the x and y variables if you want to access them within the body of the
macro. If not supplied, they are generated. x-start, y-start, x-end, and y-end
allow you to specify the start and end of the tile array to loop over. By
default, it loops over all the tiles.

To see this in use, we can update the initialize-tiles method:
#+BEGIN_SRC common-lisp
(defmethod initialize-tiles ((map game-map))
  (map-tiles-loop (map tile :col-val x :row-val y)
    (setf (aref (game-map/tiles map) x y) (make-instance 'tile :blocked t))))
#+END_SRC

If we were to expand the macro, it looks like this:
#+BEGIN_SRC common-lisp
(loop :for x :from 0 :below (if (null nil)
                                  (game-map/w map)
                                  nil)
        :do (loop :for y :from 0 :below (if (null nil)
                                            (game-map/h map)
                                            nil)
                  :do (let ((tile (aref (game-map/tiles map) x y)))
                        (declare (ignorable tile))
                        (setf (aref (game-map/tiles map) x y)
                                (make-instance 'tile :blocked
                                               initial-blocked-value)))))
#+END_SRC

*** Defining rooms and tunnels

Before we get into the map generation, let's create a helper class that we'll
use to represent rooms:
#+BEGIN_SRC common-lisp
(defclass rect ()
  ((x1 :initarg :x1 :accessor rect/x1)
   (x2 :initarg :x2 :accessor rect/x2)
   (y1 :initarg :y1 :accessor rect/y1)
   (y2 :initarg :y2 :accessor rect/y2)))

(defmethod initialize-instance :after ((rect rect) &key x y w h)
  (with-slots (x1 x2 y1 y2) rect
    (setf x1 x
          y1 y
          x2 (+ x w)
          y2 (+ y h))))
#+END_SRC

rect holds the values to represent the top left and bottom right corners of the
rectangle. We also defined the initialize-instance method for the class, and
allowed x y w h to be passed in, making it easier to create an instance of the class.

Now we can carve rooms into the map:
#+BEGIN_SRC common-lisp
(defmethod set-tile-slots ((tile tile) &key (blocked nil blocked-supplied-p) (block-sight nil block-sight-supplied-p))
  (if blocked-supplied-p
      (setf (slot-value tile 'blocked) blocked))
  (if block-sight-supplied-p
      (setf (slot-value tile 'block-sight) block-sight)))

(defmethod create-room ((map game-map) (room rect))
  (map-tiles-loop (map tile
                   :x-start (1+ (rect/x1 room)) :x-end (rect/x2 room)
                   :y-start (1+ (rect/y1 room)) :y-end (rect/y2 room))
    (set-tile-slots tile :blocked nil :block-sight nil)))
#+END_SRC

We make sure to leave the border of the room untouched, which is why the loop
starts at x1/y1 + 1, and the ending x2/y2 is excluded (remember, the
map-tiles-loop macro uses :below in the loop). This ensures that if we make two
rooms next to each other, one starting at (1,1) going to (6,6), and the other
starting at (7,1) going to (9,6) there will still be a wall in between them.
Otherwise, it would look like one room instead of two rooms.

Now, let's make a couple rooms to test. Create the following method:
#+BEGIN_SRC common-lisp
(defmethod make-map ((map game-map))
  (let ((room-1 (make-instance 'rect :x 20 :y 15 :w 10 :h 15))
        (room-2 (make-instance 'rect :x 35 :y 15 :w 10 :h 15)))
    (create-room map room-1)
    (create-room map room-2)))
#+END_SRC

In order to call this method in our main function, we're going to update our
game loop structure a bit. We'll add a new game-tick function, and update the main function to look like this:
#+BEGIN_SRC common-lisp
(defun game-tick (player entities map)
  (render-all entities map)
  (let* ((action (handle-keys))
         (move (getf action :move))
         (exit (getf action :quit)))
    (when move
      (unless (blocked-p map
                         (+ (entity/x player) (car move))
                         (+ (entity/y player) (cdr move)))
        (move player (car move) (cdr move))))

    exit))

(defun main ()
  (blt:with-terminal
      (config)
    (let ((player (make-instance 'entity
                                  :x (/ *screen-width* 2)
                                  :y (/ *screen-height* 2)
                                  :char #\@
                                  :color (blt:white)))
          (npc (make-instance 'entity
                               :x (- (/ *screen-width* 2) 5)
                               :y (/ *screen-height* 2)
                               :char #\@
                               :color (blt:yellow)))
          (entities (list player npc))
          (map (make-instance 'game-map :w *map-width* :h *map-height*)))
      (make-map (map))

      (do ((exit nil (game-tick player entities map)))
          (exit)))))
#+END_SRC

You can also remove the *map* global variable we had before, as we now create
the map locally. While we're at it, we don't really need the initialize-tiles method in the
game-map.lisp file. Since we always want the tiles initialized, we'll move that
code into the initialize-instance method:
#+BEGIN_SRC common-lisp
(defmethod initialize-instance :after ((map game-map) &key (initial-blocked-value t))
  (setf (game-map/tiles map) (make-array (list (game-map/w map) (game-map/h map))))
  (map-tiles-loop (map tile :col-val x :row-val y)
                  (setf (aref (game-map/tiles map) x y) (make-instance 'tile :blocked initial-blocked-value))))
#+END_SRC

Now if you run the game, it should look like this:
[[/cl-rltut/create-test-rooms.png]]

With the rooms being created, we should also create tunnels to connect them.
For our generation code, the tunnels will just be a combination of a horizontal
and vertical section, so there won't be any winding tunnels. Add the following
two methods:
#+BEGIN_SRC common-lisp
(defmethod create-h-tunnel ((map game-map) x1 x2 y)
  (let ((start-x (min x1 x2))
        (end-x (max x1 x2)))
    (map-tiles-loop (map tile
                     :x-start start-x :x-end (1+ end-x)
                     :y-start y :y-end (1+ y))
      (set-tile-slots tile :blocked nil :block-sight nil))))

(defmethod create-v-tunnel ((map game-map) y1 y2 x)
  (let ((start-y (min y1 y2))
        (end-y (max y1 y2)))
    (map-tiles-loop (map tile
                     :x-start x :x-end (1+ x)
                     :y-start start-y :y-end (1+ end-y))
      (set-tile-slots tile :blocked nil :block-sight nil))))
#+END_SRC

Let's test it out by updating our make-map method:
#+BEGIN_SRC common-lisp
(defmethod make-map ((map game-map))
  (let ((room-1 (make-instance 'rect :x 20 :y 15 :w 10 :h 15))
        (room-2 (make-instance 'rect :x 35 :y 15 :w 10 :h 15)))
    (create-room map room-1)
    (create-room map room-2))

  (create-h-tunnel map 25 40 23))
#+END_SRC

Running the game now should look like:
[[/cl-rltut/test-tunnel.png]]
*** Generating the dungeon
Now that we can create rooms and tunnels, it's time to move on to the actual
dungeon generation. It will be relatively basic: we'll create a bunch of rooms,
make sure they don't overlap, and connect them together.

First, add a couple methods to the rect class to assist with detecting when two
rooms overlap:
#+BEGIN_SRC common-lisp
(defmethod center ((rect rect))
  (with-slots (x1 x2 y1 y2) rect
    (let ((center-x (round (/ (+ x1 x2) 2)))
          (center-y (round (/ (+ y1 y2) 2))))
      (values center-x center-y))))

(defmethod intersect ((rect rect) (other rect))
  "Returns T if this RECT intersects with OTHER"
  (and (<= (rect/x1 rect) (rect/x2 other))
       (>= (rect/x2 rect) (rect/x1 other))
       (<= (rect/y1 rect) (rect/y2 other))
       (>= (rect/y2 rect) (rect/y1 other))))
#+END_SRC

Add a couple of variables to the cl-rltut.lisp file, to use with our generation:
#+BEGIN_SRC common-lisp
(defparameter *room-max-size* 10)
(defparameter *room-min-size* 6)
(defparameter *max-rooms* 30)
#+END_SRC

Now, update the make-map method signature to take in those variables, and start
calculating the position and size for the rooms:
#+BEGIN_SRC common-lisp
(defmethod make-map ((map game-map) max-rooms room-min-size room-max-size map-width map-height player)
  (do* ((rooms nil)
        (num-rooms 0)
        (room-index 0 (1+ room-index))
        (w (+ (random (- room-max-size room-min-size)) room-min-size)
           (+ (random (- room-max-size room-min-size)) room-min-size))
        (h (+ (random (- room-max-size room-min-size)) room-min-size)
           (+ (random (- room-max-size room-min-size)) room-min-size))
        (x (random (- map-width w))
           (random (- map-width w)))
        (y (random (- map-height h))
           (random (- map-height h)))
        (new-room (make-instance 'rect :x x :y y :w w :h h)
                  (make-instance 'rect :x x :y y :w w :h h))
        (can-place-p t t))
       ((>= room-index max-rooms))))
#+END_SRC

We're calculating each room's width and height as a random size between the
room-min-size and room-max-size. The x and y position is a random point within
the map. We then create a new-room variable with these calculated values. The
rooms variable is going to hold all the rooms that we create, so we can check
for overlaps, and the room-index and num-rooms will help with looking up the
previous room. When we generate the tunnels, we'll just be connecting the
current room to the previously created room.

Update the do* body to check for intersections:
#+BEGIN_SRC common-lisp
(dolist (other-room rooms)
  (if (intersect new-room other-room)
      (setf can-place-p nil)))
#+END_SRC

That just loops over the rooms list (which we'll populate later), and checks if
the current room we're placing intersects with any of the other rooms. If there
is an intersection, we're setting the can-place-p variable to show that we
shouldn't actually create this room.

After that dolist loop, we can create the new room, and connect it to the
previous room:
#+BEGIN_SRC common-lisp
(when can-place-p
  (create-room map new-room)
  (multiple-value-bind (new-x new-y) (center new-room)
    (if (zerop num-rooms)
        (setf (entity/x player) new-x
              (entity/y player) new-y)
        (multiple-value-bind (prev-x prev-y) (center (car (last rooms)))
          (cond ((= (random 2) 1)
                 (create-h-tunnel map prev-x new-x prev-y)
                 (create-v-tunnel map prev-y new-y new-x))
                (t
                 (create-v-tunnel map prev-y new-y prev-x)
                 (create-h-tunnel map prev-x new-x new-y)))))
    (if (null rooms)
        (setf rooms (list new-room))
        (push new-room (cdr (last rooms))))
    (incf num-rooms)))
#+END_SRC

The tunnel creation randomly decides whether to use a horizontal or vertical
tunnel first, so that it doesn't look so uniform. The tunnel is created from the
center of the previous room, to the center of the new room. After the room is
created, it's added to the rooms list so that we can check for overlaps in the
next rooms.

Running the code now, you should see a complete dungeon:
[[/cl-rltut/dungeon-generation.png]]

Note that since it's randomly generated, your output won't look exactly the same.

*** Conclusion
That's all there is to it. It's a pretty simple algorithm, but gives decent
results. There are plenty of other algorithms to generate different looking
dungeons. For example, you can use a type of [[http://journal.stuffwithstuff.com/2014/12/21/rooms-and-mazes/][maze algorithm]] to make the tunnels
between rooms more interesting.

You can find the current state of the code on [[https://github.com/nwforrer/cl-rltut/tree/part-3][Github]]. The list of changes since
the previous tutorial can be found at
[[https://github.com/nwforrer/cl-rltut/compare/part-2...part-3]].

Continue to the [[/posts/roguelike-tutorial-part4][part 4]].
** DONE Roguelike tutorial for Common Lisp - Part 4 - Field of view :roguelike::gamedev:lisp:tutorial:
CLOSED: [2019-07-14 Sun 22:43]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part4
:END:
This tutorial series is based on the [[http://rogueliketutorials.com][Python Roguelike Tutorial]]. This will be
covering [[http://rogueliketutorials.com/tutorials/tcod/part-4/][Part 4]] of that tutorial.

In this post, we'll be computing the Field Of View (FOV) of the player. This
will make exploring the dungeon much more interesting. When the game starts,
only the tiles near the player will be visible. As the player explores the
dungeon, the tiles that the player moves past will also become visible, allowing
the map to be shown. However, any items or enemies will only be visible if they
are within the players sight at a given time. Once the player moves on, the
item/enemy will no longer be displayed.

This post will differ from the Python Roguelike Tutorial more-so than previous
posts. In the Python Tutorial, the libtcod library is being used, which provides
FOV algorithms to calculate the FOV for you. However, we're using
BearLibTerminal which does not have such algorithms. We could import the libtcod
library to take advantage of those algorithms, but where's the fun in that?
Instead we'll be writing the algorithm from scratch. The reference I'm using
for this is:
[[http://www.roguebasin.com/index.php?title=Line_of_Sight_-_Tobias_Downer][http://www.roguebasin.com/index.php?title=Line_of_Sight_-_Tobias_Downer]].
RogueBasin has many [[http://www.roguebasin.com/index.php?title=Category:FOV][articles and techniques]] for calculating the FOV. We'll be
taking a very simplistic approach, which will work well enough for our needs.

*** Calculating the Field of View
First, we'll need a way to track which tiles are visible to the player, so that
we can render them differently from the non-visible tiles:
#+BEGIN_SRC common-lisp
(defclass tile ()
  ((blocked :initarg :blocked
            :accessor tile/blocked
            :initform nil)
   (block-sight :initarg :block-sight
                :accessor tile/block-sight
                :initform nil)
   (visible :initarg :visible
            :accessor tile/visible
            :initform nil)))
#+END_SRC

The way the algorithm works, is we'll start at the player's position, trace rays
in every direction, and check each tile that the ray intersects with. If the
tile's block-sight slot is set to nil, then we'll set it's visible slot to t.
Once a ray reaches a tile that has block-site set to t, then we stop tracing
that ray, so all the tiles after it have their visible tiles set to nil.

Create a new file named fov.lisp, and create a fov function, and a way to reset
the visible slot on all tiles:
#+BEGIN_SRC common-lisp
(defparameter *fov-distance* 5)

(defun reset-visibility (map)
  (map-tiles-loop (map tile)
    (setf (tile/visible tile) nil)))

(defun fov (map x y)
  (reset-visibility map))
#+END_SRC

Now, we'll trace 360 lines around the player's position, one for each degree of
a circle. Each line will be `fov-distance` long. We will use [[https://en.wikipedia.org/wiki/Linear_interpolation][linear
interpolation]] to take incremential steps over the line. At each step, we'll
check that we haven't gone outside the bounds of the map, and then check if the
tile at that step has block-sight set to t. If neither of those are true, then
the tile must be visible. The full function looks like this:
#+BEGIN_SRC common-lisp
(defun degree-to-radian (degree)
  (* degree (/ pi 180)))

(defun diagonal-distance (x0 y0 x1 y1)
  (let ((dx (- x0 x1))
        (dy (- y1 y0)))
    (max (abs dx) (abs dy))))

(defun lerp (start end time)
  (+ start (* time (- end start))))

(defun fov (map x y)
  (reset-visibility map)

  ;; loop aver 360 degrees
  (dotimes (degree 360)
    (let* ((rad (degree-to-radian degree))
           (nx (round (+ (* (cos rad) *fov-distance*) x)))
           (ny (round (+ (* (sin rad) *fov-distance*) y)))
           (d (diagonal-distance x y nx ny)))
      (dotimes (tile d)
        (let ((tx (round (lerp x nx (/ tile d))))
              (ty (round (lerp y ny (/ tile d)))))
          (if (or (< tx 0) (> tx (game-map/w map)))
              (return))
          (if (or (< ty 0) (> ty (game-map/h map)))
              (return))

          ;; if tile is a wall, mark as seen and stop the line early
          (when (tile/block-sight (aref (game-map/tiles map) tx ty))
            (setf (tile/visible (aref (game-map/tiles map) tx ty)) t)
            (return))

          (setf (tile/visible (aref (game-map/tiles map) tx ty)) t))))))
#+END_SRC

*** Rendering the field of view
Now that we know which tiles are visible to the player, we can update our
rendering to display them differently. Update the color map to include the
colors we'll use to display the visible floors and walls:
#+BEGIN_SRC common-lisp
(defparameter *color-map* (list :dark-wall (blt:rgba 0 0 100)
                                :dark-ground (blt:rgba 50 50 150)
                                :light-wall (blt:rgba 130 110 50)
                                :light-ground (blt:rgba 200 180 50)))
#+END_SRC

Now we can update the render-all function to change the tile colors depending on
whether the tile is visible or not:
#+BEGIN_SRC common-lisp
(defun render-all (entities map)
  (blt:clear)
  (dotimes (y *map-height*)
    (dotimes (x *map-width*)
      (let* ((tile (aref (game-map/tiles map) x y))
             (wall (tile/block-sight tile))
             (visible (tile/visible tile)))
        (if visible
            (if wall
                (setf (blt:background-color) (getf *color-map* :light-wall))
                (setf (blt:background-color) (getf *color-map* :light-ground)))
            (if wall
                (setf (blt:background-color) (getf *color-map* :dark-wall))
                (setf (blt:background-color) (getf *color-map* :dark-ground)))))))
  (mapc #'(lambda (entity) (draw entity map)) entities)
  (setf (blt:background-color) (blt:black))
  (blt:refresh))
#+END_SRC

Now if you run the game, you should see something like this:
[[/cl-rltut/display-fov.png]]

*** Exploration
One issue with how this works is the entire map is visible to the player at the
start. We'd rather hide the map, and only start to display it as the player
explores. To do that, we'll add another tile slot to track which tiles have been
explored, and then mark that `t` whenever the tile becomes visible. The
difference between `explored` and `visible` is that once `explored` is set to t,
it will not be reset.
#+BEGIN_SRC common-lisp
(defclass tile ()
  ((blocked :initarg :blocked
            :accessor tile/blocked
            :initform nil)
   (block-sight :initarg :block-sight
                :accessor tile/block-sight
                :initform nil)
   (visible :initarg :visible
            :accessor tile/visible
            :initform nil)
   (explored :initarg :explored
             :accessor tile/explored
             :initform nil)))
#+END_SRC

Now in the fov function, whenever the visible slot is set to true, also set the
explored slot to t:
#+BEGIN_SRC common-lisp
(when (tile/block-sight (aref (game-map/tiles map) tx ty))
  (setf (tile/visible (aref (game-map/tiles map) tx ty)) t
        (tile/explored (aref (game-map/tiles map) tx ty)) t)
  (return))

(setf (tile/visible (aref (game-map/tiles map) tx ty)) t
      (tile/explored (aref (game-map/tiles map) tx ty)) t)
#+END_SRC

With that data being tracked, we can update the renderer to only show visible or
explored tiles.
#+BEGIN_SRC common-lisp
(defun render-all (entities map)
  (blt:clear)
  (dotimes (y *map-height*)
    (dotimes (x *map-width*)
      (let* ((tile (aref (game-map/tiles map) x y))
             (wall (tile/block-sight tile))
             (visible (tile/visible tile))
             (explored (tile/explored tile)))
        (cond (visible
               (if wall
                   (setf (blt:background-color) (getf *color-map* :light-wall))
                   (setf (blt:background-color) (getf *color-map* :light-ground)))
               (setf (blt:cell-char x y) #\Space))
              (explored
               (if wall
                   (setf (blt:background-color) (getf *color-map* :dark-wall))
                   (setf (blt:background-color) (getf *color-map* :dark-ground)))
               (setf (blt:cell-char x y) #\Space))))))
  (mapc #'(lambda (entity) (draw entity map)) entities)
  (setf (blt:background-color) (blt:black))
  (blt:refresh))
#+END_SRC

The last step we'll want to do is to also update the entity draw method. We'll
only want to draw entities that the player can see:
#+BEGIN_SRC common-lisp
(defmethod draw ((e entity) (map game-map))
  (with-slots (x y char color) e
    (if (tile/visible (aref (game-map/tiles map) x y))
        (setf
         (blt:background-color) (blt:cell-background-color x y)
         (blt:color) color
         (blt:cell-char x y) char))))
#+END_SRC

Now if you run the game, you should see something like this (after exploring a
couple rooms):
[[/cl-rltut/fov-exploration.png]]

*** Conclusion
That's all there is to it. If you're interested in other more efficient
algorithms, I'd recommend checking out the [[http://www.roguebasin.com/index.php?title=Category:FOV][FOV section on RogueBasin]].
** TODO Roguelike tutorial for Common Lisp - Part 5 - Placing enemies :roguelike::gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part5
:END:
** TODO Roguelike tutorial for Common Lisp - Part 6 - Combat :roguelike::gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part6
:END:
** TODO Roguelike tutorial for Common Lisp - Part 7 - Creating the interface :roguelike::gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part7
:END:
** TODO Roguelike tutorial for Common Lisp - Part 8 - Items and inventory :roguelike::gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part8
:END:
** TODO Roguelike tutorial for Common Lisp - Part 9 - Ranged scrolls and targeting :roguelike::gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part9
:END:
** TODO Roguelike tutorial for Common Lisp - Part 10 - Saving and loading :roguelike::gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part10
:END:
** TODO Roguelike tutorial for Common Lisp - Part 11 - Multiple dungeon floors :roguelike::gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part11
:END:
** TODO Roguelike tutorial for Common Lisp - Part 12 - Increasing the difficulty :roguelike::gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part12
:END:
** TODO Roguelike tutorial for Common Lisp - Part 13 - Gearing up :roguelike::gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part13
:END:
