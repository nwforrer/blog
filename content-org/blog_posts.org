#+HUGO_SECTION: posts
#+HUGO_BASE_DIR: ../
#+author: Nick Forrer

* Hello
** Hello World
:PROPERTIES:
:EXPORT_FILE_NAME: hello-world
:EXPORT_DATE: 2019-06-23
:END:
Testing the site
* Roguelike Tutorials                        :@tutorials:@roguelike_tutorial:
** DONE Roguelike tutorial for Common Lisp - Part 0 - Setup :roguelike:gamedev:lisp:tutorial:
CLOSED: [2019-06-23 Sun 10:24]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part0
:END:
This set of tutorials is going to follow the [[http://rogueliketutorials.com/tutorials/tcod/][Python TCOD tutorial]], but will be
written in Common Lisp and use the BearLibTerminal library.

*** Prior Knowledge
This tutorial assumes you are familiar with programming in Common Lisp. If
you're not familiar, I would highly recommend checking out [[http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/][A Road to Common Lisp]]
on Steve Losh's blog. It provides many valuable resources to get up to speed
with Common Lisp, and is how I got started.
*** Installation
You will need the following installed:
- A Common Lisp implementation. I will be using and testing my code against
  [[http://www.sbcl.org/][SBCL]].
- [[https://www.quicklisp.org/beta/][Quicklisp]]
- An editor. I use Emacs, with the [[https://github.com/hlissner/doom-emacs][Doom Emacs]] configuration.

I run Linux (Fedora) on my machine, and SBCL is available in the default
repositories. If it is not available in your distro (or if you're not running
Linux), check out the [[http://www.sbcl.org/getting.html][getting started]] page.

Quicklisp should be configured based on the installation guide on their [[https://www.quicklisp.org/beta/][home page]].

For the Emacs configuration, the most important peice is to have a REPL
available. I use the [[https://github.com/joaotavora/sly][sly]] package, although [[https://common-lisp.net/project/slime/][SLIME]] is popular as well. Having a
REPL running in your editor makes the development process much more efficient
and enjoyable.

*** Project setup
Once you have everything installed that you need, you can get the project
skeleton created, with the needed dependencies. Since you have Quicklisp
installed, it will be easy to generate a project skeleton using [[https://www.xach.com/lisp/quickproject/][Quickproject]].

First, open emacs and start your REPL (if you're using sly, the Emacs command is
just M-x "sly"). In the REPL:

#+BEGIN_SRC common-lisp
(ql:quickload :quickproject)
(quickproject:make-project #p"cl-rltut" :depends-on '(:cl-blt))
#+END_SRC

That should create a "cl-rltut" directory within the current working
directory of your REPL (this can be shown for sly with the "sly-pwd" command,
and changed with the "sly-cd" command). Within the project directory, you should
see an ASDF file named "cl-rltut.asd", which looks like the following:
#+BEGIN_SRC common-lisp
(asdf:defsystem #:cl-rltut
  :description "Describe cl-rltut here"
  :author "Nick Forrer"
  :license  "MIT"
  :version "0.0.1"
  :serial t
  :depends-on (#:cl-blt)
  :components ((:file "package")
               (:file "cl-rltut")))
#+END_SRC

You will also need to download the cl-blt package, which contains the
Common Lisp bindings for BearLibTerminal. The reason for this is because
cl-blt is not currently available in an online repository that
Quicklisp could download it automatically. Download the package using:

#+BEGIN_SRC sh
git clone https://github.com/sjl/cl-blt.git ~/quicklisp/local-projects/cl-blt
#+END_SRC

That will clone the cl-blt Git repo into a directory that Quicklisp will look at
when trying to load an ASDF system. For reference, the latest commit on the
cl-blt repository is `ee69ac7bfb473e9cdd8c2d50d45ef288ef315ff3` at the time of
writing. If you want to guarantee you're using the same version as I am, just
make sure you checkout that commit.

In addition to the Common Lisp bindings, you will also need the BearLibTerminal
library itself. Download the appropriate binary for your system from
http://foo.wyrd.name/en:bearlibterminal#download. Once downloaded, extract the
archive and find the shared library dependency. For the Linux archive, this will
be Linux64/libBearLibTerminal.so (assuming you are using a 64-bit OS). This file
should be placed in a "lib" directory in the root of your project.

NOTE: Windows users may need to add the following to their package.lisp file, to
ensure the bearlibterminal library is found:
#+BEGIN_SRC lisp
(cffi:define-foreign-library blt:bearlibterminal
  (t "lib/BearLibTerminal.dll"))

(cffi:use-foreign-library blt:bearlibterminal)
#+END_SRC

To make it easier to load your project from the REPL, you can create a symlink
in the local-projects directly that points to your project, so that Quicklisp
can always find it (use the correct path to your project instead of ~/src/lisp/cl-rltut):

#+BEGIN_SRC sh
ln -s ~/src/lisp/cl-rltut ~/quicklisp/local-projects
#+END_SRC

With all of that in place, you should now be able to load your projects system
in the REPL to ensure in can find all the dependencies with:

#+BEGIN_SRC common-lisp
(ql:quickload :cl-rltut)
#+END_SRC

Assuming you don't see any errors, then your project is all set to continue with
the tutorial! To see what the project should look like at this point, you can
find the current state for Part 0 here: https://github.com/nwforrer/cl-rltut/tree/part-0.

*** Questions and Feedback
If you run into any issues, or have questions/feedback, please open an issue on this
blogs [[https://github.com/nwforrer/blog/issues][GitHub repository]].

Continue to the [[/posts/roguelike-tutorial-part1][next tutorial]].

** DONE Roguelike tutorial for Common Lisp - Part 1 - Drawing the player :roguelike:gamedev:lisp:tutorial:
CLOSED: [2019-06-25 Tue 20:10]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part1
:END:
Welcome to the first part of the tutorial! If you haven't already, please check
out [[/posts/roguelike-tutorial-part0][Part 0]] to get the project created.

This tutorial series is based on the [[http://rogueliketutorials.com][Python Roguelike Tutorial]]. This will be
covering [[http://rogueliketutorials.com/tutorials/tcod/part-1/][Part 1]] of that tutorial as closely as possible, with the exception of
different structure to support more idiomatic Common Lisp, and with using
BearLibTerminal instead of tcod.

*** Opening a window
First we'll work on getting a window created. The Common Lisp bindings we're
using for BearLibTerminal provide some higher level functions to make
interacting with the library more "lispy", so some of the function names won't
align exactly with what you'll see in the BearLibTerminal documentation
(although you can also call those methods, we'll mostly use the high level
functions). You can find the documentation for the high-level API here:
https://sjl.bitbucket.io/cl-blt/reference/.

Open up emacs, and start your REPL. Load your project and change
into your package:

#+BEGIN_SRC common-lisp
(ql:quickload :cl-rltut)
(in-package :cl-rltut)
#+END_SRC

Now in the cl-rltut.lisp file, create a main function to open the window, set
some configs, and enter into a loop:

#+BEGIN_SRC common-lisp
(defparameter *screen-width* 80)
(defparameter *screen-height* 50)

(defun draw ()
  (blt:clear)
  (blt:refresh))

(defun config ()
  (blt:set "window.resizeable = true")
  (blt:set "window.size = ~Ax~A" *screen-width* *screen-height*)
  (blt:set "window.title = Roguelike"))

(defun main()
  (blt:with-terminal
    (config)
    (loop :do
      (draw)
      (blt:key-case (blt:read)
                    (:escape (return))
                    (:close (return))))))
#+END_SRC

If you evaluate the buffer with `sly-eval-buffer`, you will be able to run the
game from your REPL with:
#+BEGIN_SRC common-lisp
(main)
#+END_SRC

If everything was done correctly, you
should see an empty window:

[[/cl-rltut/empty-window.png]]

Exciting! Let's step through the code to see what's going on.

#+BEGIN_SRC common-lisp
(defparameter *screen-width* 80)
(defparameter *screen-height* 50)
#+END_SRC

This creates two global variables to store the width and height of the window,
in cells. By default, the size of the cell is selected based on the font size.

#+BEGIN_SRC common-lisp
(blt:with-terminal ... )
#+END_SRC

This is a macro that wraps the terminal_open and terminal_close functions of the
underlying library. The macro will open a terminal at the start, execute
whatever code we pass within the call, and then close the terminal.

#+BEGIN_SRC common-lisp
(defun config ()
  (blt:set "window.resizeable = true")
  (blt:set "window.size = ~Ax~A" *screen-width* *screen-height*)
  (blt:set "window.title = Roguelike"))
#+END_SRC

The `set` function is how you configure various library options, such as
managing fonts, or setting window settings like we do here. The nice thing about
the Common Lisp wrapper is that it allows the use of format directives to format
the string. We take advantage of that when setting the window.size property to
the width and height variables that we defined earlier. If you're not familiar
with Common Lisp format directives, you can read more about them here: http://www.gigamonkeys.com/book/a-few-format-recipes.html.

#+BEGIN_SRC common-lisp
(loop :do ... )
#+END_SRC

This just starts up an endless loop that our game will run in.

#+BEGIN_SRC common-lisp
(blt:key-case (blt:read)
              (:escape (return))
              (:close (return)))
#+END_SRC

`key-case` is another macro defined in the high level API of the Common Lisp
bindings. This is used to handle keyboard input. As the first parameter, it
takes in an event from the keyboard. We're using the `read` function to get
this data. If there are no events in the input queue, `read` will wait for an
event to come. This blocking behaviour is perfect for our case, because it will
make the turn-based gameplay easier.
The second parameter to the `key-case` macro is a list of clauses. The first
part of a clause, for example :escape, will match with the event returned from
the `read` call. If the event is that the escape button was pressed, then the
second part of the clause wil be executed. In that case, we just return from the
main function to close the program. Only the code in a matching clause will be executed.

#+BEGIN_SRC common-lisp
(defun draw ()
  (blt:clear)
  (blt:refresh))
#+END_SRC

Here we just have a placeholder draw function, which will clear the window to
black and then call `refresh`. All of the drawing that BearLibTerminal does is
to an off-screen buffer, so we won't see our changes displayed until the
`refresh` function is called. While we aren't actually drawing anything yet,
this is needed to make the window visible. BearLibTerminal will only display the
window with the first `refresh` call after opening the window. Prior to that,
the window will stay invisible.

*** Adding the player
Now that we have a window, let's get the player drawn to the screen. Update the
draw function to look like this:

#+BEGIN_SRC common-lisp
(defun draw()
  (blt:clear)
  (setf (blt:color) (blt:white)
        (blt:cell-char 10 10) #\@)
  (blt:refresh))
#+END_SRC

Pretty easy! When blt:color is set, that color will be used for all subsequent
drawing until the color is changed again. Then, we set the cell at 10x10 to the
@ character. If all works, you should see this when you run the game:

[[/cl-rltut/drawing-player.png]]

Next we'll want to be able to move the player around. We're already capturing
some keyboard input, so it won't be difficult to capture the arrow keys as well.
Then we just need to have a way to track the players position so that we can
update it when an arrow key is pressed. Make updates to the following functions:

#+BEGIN_SRC common-lisp
(defun draw (player-x player-y)
  (blt:clear)
  (setf (blt:color) (blt:white)
        (blt:cell-char player-x player-y) #\@)
  (blt:refresh))

(defun handle-keys ()
  (let ((action nil))
    (blt:key-case (blt:read)
                  (:up (setf action (list :move (cons 0 -1))))
                  (:down (setf action (list :move (cons 0 1))))
                  (:left (setf action (list :move (cons -1 0))))
                  (:right (setf action (list :move (cons 1 0))))
                  (:escape (setf action (list :quit t)))
                  (:close (setf action (list :quit t))))
    action))

(defun main()
  (blt:with-terminal
    (config)
    (loop :with player-x = (/ *screen-width* 2)
          :and player-y = (/ *screen-height* 2)
          :do
             (draw player-x player-y)
             (let* ((action (handle-keys))
                    (move (getf action :move))
                    (exit (getf action :quit)))
               (if exit
                   (return))
               (when move
                 (incf player-x (car move))
                 (incf player-y (cdr move)))))))
#+END_SRC

If you run the game now, you should be able to move the player around using the
arrow keys.

We created a new "handle-keys" function, and moved the input handling code into
it. handle-keys returns a property list. When one of the arrow keys is pressed,
the function would return something like:
#+BEGIN_SRC common-lisp
'(:move (0 . 1))
#+END_SRC

When looking at the return value, we can check what type of action is returned
with:
#+BEGIN_SRC common-lisp
(getf action :move)
#+END_SRC

If we run that on the previous example, the result would be the (0 . 1), telling
us that there was a move action to increment the player-y by 1. We can get the x
and y portion of that with the car and cdr functions respectively. If there was no
move action, getf would return nil.

We also added player-x and player-y as local variables on the loop. This will be
changed in the future to add some more structure, but works for now.

*** Conclusion
That's going to be it for this tutorial. You can find the current state of the
code on [[https://github.com/nwforrer/cl-rltut/tree/part-1][Github]]. The list of changes since the previous tutorial can be found at
https://github.com/nwforrer/cl-rltut/compare/part-0...part-1.

If you run into any issues, or have questions/feedback, please open an issue on this
blogs [[https://github.com/nwforrer/blog/issues][GitHub repository]].

Continue to the [[/posts/roguelike-tutorial-part2][part 2]].
** DONE Roguelike tutorial for Common Lisp - Part 2 - Generic entity and map :roguelike:gamedev:lisp:tutorial:
CLOSED: [2019-06-27 Thu 21:53]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part2
:END:
This tutorial series is based on the [[http://rogueliketutorials.com][Python Roguelike Tutorial]]. This will be
covering [[http://rogueliketutorials.com/tutorials/tcod/part-2/][Part 2]] of that tutorial.

It's time to start thinking about how we want to structure our entities, and
what the map will look like. We will be creating a generic entity class that all
entities in the game will use, and introduce the concept of how the map will be
structured. We'll be using classes and generic methods provided with CLOS here.
If you're unfamiliar with CLOS, there is a good overview in [[https://lispcookbook.github.io/cl-cookbook/clos.html][The Common Lisp Cookbook]].

*** Generic entity
The first thing we'll be doing is creating a class to represent entities in the
game, storing it's position, color, and character to render.
#+BEGIN_SRC common-lisp
(defclass entity ()
  ((x :initarg :x :accessor entity/x)
   (y :initarg :y :accessor entity/y)
   (char :initarg :char :accessor entity/char)
   (color :initarg :color :accessor entity/color)))
#+END_SRC

Next we can create some methods on that class to handle drawing and moving the
entity.
#+BEGIN_SRC common-lisp
(defmethod move ((e entity) dx dy)
  (incf (entity/x e) dx)
  (incf (entity/y e) dy))

(defmethod draw ((e entity))
  (with-slots (x y char color) e
    (setf (blt:color) color
          (blt:cell-char x y) char)))
#+END_SRC

We'll rename our old draw function to render-all, and from there call the entities draw
method for each entity.
#+BEGIN_SRC common-lisp
(defun render-all (entities)
  (blt:clear)
  (mapc #'draw entities)
  (blt:refresh))
#+END_SRC
We're just mapping the draw method call over the list of all entities passed
into the function.

Now we actually need to create some entities. Update the main function as
follows:
#+BEGIN_SRC common-lisp
(defun main()
  (blt:with-terminal
    (config)
    (loop :with player = (make-instance 'entity
                                        :x (/ *screen-width* 2)
                                        :y (/ *screen-height* 2)
                                        :char #\@
                                        :color (blt:white))
          :and npc = (make-instance 'entity
                                    :x (- (/ *screen-width* 2) 5)
                                    :y (/ *screen-height* 2)
                                    :char #\@
                                    :color (blt:yellow))
          :with entities = (list player npc)
          :do
             (render-all entities)
             (let* ((action (handle-keys))
                    (move (getf action :move))
                    (exit (getf action :quit)))
               (when exit
                 (return))
               (when move
                 (move player (car move) (cdr move)))))))
#+END_SRC
Here we removed the player-x and player-y variables, and instead create a player
entity. We have also added an npc entity to show how we can use the entity class
for more than just the player. We add those two entities to an entities list,
which gets passed to the render-all function. We also call the new move method
on the player entity when a move action is requested.

If you run the game now, it should look like the following:
[[/cl-rltut/generic-entity-class.png]]

The NPC should look like a yellow @ symbol, and player movement should work like it
did before.

*** Creating the map
Now that we can create and render entities, we should create a map for them to
move around in. We're not going to procedurally generate the map yet (that will
be in the next tutorial), but we'll create the structure needed to render the
map.

Before we do, let's create a new file to store the map related code, as it can
become pretty large once we're generating it. Create a file named
"game-map.lisp" in the root of your project, and declare that it's in the same
package by placing this at the top of the file:
#+BEGIN_SRC common-lisp
(in-package #:cl-rltut)
#+END_SRC

You also need to update the ASDF file to include the new file in your system:
#+BEGIN_SRC common-lisp
(asdf:defsystem #:cl-rltut
  :description "Describe cl-rltut here"
  :author "Nick Forrer"
  :license "MIT"
  :version "0.0.1"
  :serial t
  :depends-on (#:cl-blt)
  :components ((:file "package")
               (:file "cl-rltut")
               (:file "game-map")))
#+END_SRC

In the "game-map.lisp" file, create a new tile class.
#+BEGIN_SRC common-lisp
(defclass tile ()
  ((blocked :initarg :blocked
            :accessor tile/blocked
            :initform nil)
   (block-sight :initarg :block-sight
                :accessor tile/block-sight
                :initform nil)))

(defmethod initialize-instance :after ((tile tile) &rest initargs)
  (declare (ignore initargs))
  (with-slots (blocked block-sight) tile
    (if (null block-sight)
        (setf block-sight blocked))))
#+END_SRC

The blocked slot will indicate whether this tile will block movement, such as if
it represents a wall. The block-sight slot will indicate if this tile will block
an entities vision. These are separate so that we can support things like lava
tiles, where we don't want an entity to walk through it, but they can see past
it. We will implement field-of-vision later, but that will determine which tiles
the player can see at a given time.
We've also defined an after method for initialize-instance for the tile class.
This will be called after a make-instance is called for the class, and the slots
are initialized. Here, we want to make sure the block-sight slot is set to true
if blocked is also true.

Now lets create a game-map class, which will hold a 2D array of tiles to make up
our map.
#+BEGIN_SRC common-lisp
(defclass game-map ()
  ((width :initarg :w :accessor game-map/w)
   (height :initarg :h :accessor game-map/h)
   (tiles :accessor game-map/tiles)))

(defmethod initialize-instance :after ((map game-map) &rest initargs)
  (declare (ignore initargs))
  (setf (game-map/tiles map) (make-array (list (game-map/w map) (game-map/h map)))))
#+END_SRC

We also define an initialize-instance method for game-map. This initializes the
tiles slot to an array with WxH dimensions.

Next create a function to initialize the tiles in the array.
#+BEGIN_SRC common-lisp
(defun initialize-tiles ((map game-map))
  (dotimes (y (game-map/h map))
    (dotimes (x (game-map/w map))
      (setf (aref (game-map/tiles map) x y) (make-instance 'tile))))

  (setf (tile/blocked (aref (game-map/tiles map) 30 22)) t)
  (setf (tile/block-sight (aref (game-map/tiles map) 30 22)) t)
  (setf (tile/blocked (aref (game-map/tiles map) 31 22)) t)
  (setf (tile/block-sight (aref (game-map/tiles map) 31 22)) t)
  (setf (tile/blocked (aref (game-map/tiles map) 32 22)) t)
  (setf (tile/block-sight (aref (game-map/tiles map) 32 22)) t))
#+END_SRC
This loops through all the tiles in the map, and initializes them to a new
instance of the tile class. This will create all the tiles with blocked and
block-sight set to nil. We then set 3 of the tiles to have blocked and
block-sight set to true so we can test it.

We now have a map created, but we can't see it yet. Back in the "cl-rltut.lisp"
file, update the render-all function to take the map as a parameter and render
all it's tiles.
#+BEGIN_SRC common-lisp
(defparameter *color-map* (list :dark-wall (blt:rgba 0 0 100)
                                :dark-ground (blt:rgba 50 50 150)))

(defun render-all (entities map)
  (blt:clear)
  (dotimes (y (game-map/h map))
    (dotimes (x (game-map/w map))
      (let* ((tile (aref (game-map/tiles map) x y))
             (wall (tile/blocked tile)))
        (if wall
            (setf (blt:background-color) (getf *color-map* :dark-wall))
            (setf (blt:background-color) (getf *color-map* :dark-ground))))
      (setf (blt:cell-char x y) #\Space)))

  (mapc #'draw entities)

  (setf (blt:background-color) (blt:black))
  (blt:refresh))
#+END_SRC

We first declare a color-map global variable as a property list to hold a
mapping of keys (like "dark-wall") to their BearLibTerminal color value. This
just makes it easier to reference colors, and easy to update them later if we
wanted to. Then, in the render-all method, we loop over all of the tiles in the
map. We check if the blocked slot is true, and if so, set blt:background-color
to dark-wall. Whenever you set the background-color, all subsequent draw calls
will use it as the background in the cell you draw to. If the tile is not
blocked, we set background-color to dark-ground. We then draw an empty space at
the tiles cell, which will just populate the background of the cell.
After the entire map and all entities are drawn, we reset the background-color
to black.

Now in the main function, lets create a map instance and pass it to the
render-all function to actually see it displayed.
#+BEGIN_SRC common-lisp
(defparameter *map-width* 80)
(defparameter *map-height* 45)

(defparameter *map* nil)

(defun main ()
  (blt:with-terminal
    (config)
    (setf *map* (make-instance 'game-map :w *map-width* :h *map-height*))
    (initialize-tiles *map*)
    (loop :with player = (make-instance 'entity
                                        :x (/ *screen-width* 2)
                                        :y (/ *screen-height* 2)
                                        :char #\@
                                        :color (blt:white))
          :and npc = (make-instance 'entity
                                    :x (- (/ *screen-width* 2) 5)
                                    :y (/ *screen-height* 2)
                                    :char #\@
                                    :color (blt:yellow))
          :with entities = (list player npc)
          :do
             (render-all entities *map*)
             (let* ((action (handle-keys))
                    (move (getf action :move))
                    (exit (getf action :quit)))
               (when exit
                 (return))
               (when move
                 (move player (car move) (cdr move)))))))
#+END_SRC

We create two global variables to hold the map width and height (in cells). The
height is set to 5 cells smaller than the height of the window. This is so that
there is some blank space at the bottom of the window to be used for messages,
which we'll get to in a later tutorial. We also declare the map variable as a
global. This isn't really necessary, and could easily be created as a local
variable in the main function. The reason I've declared it global is so that it
can be looked at and manipulated in the REPL. It's up to you whether you find
that useful enough to make the variable global.
The changes to the main method are straight forward. We initialize an instance
of the game-map class, and initialize it's tiles. Then we just pass it along to
the render-all method to have it displayed.

If you run the game now, it should look like this:
[[/cl-rltut/initial-map-render.png]]

The three dark tiles are the walls. You'll notice that you can still walk
through them, which isn't correct. We can easily fix that by first adding a
helper method in the "game-map-lisp" file:
#+BEGIN_SRC common-lisp
(defmethod blocked-p ((map game-map) x y)
  (tile/blocked (aref (game-map/tiles map) x y)))
#+END_SRC
This takes in the map and an x,y coordinate, and returns whether that tile is
blocked.

We then just need to call that with the coordinates we're moving to, and if it's
blocked, don't move the player. Update the `(when move)` block in the main
function like:
#+BEGIN_SRC common-lisp
(when move
  (unless (blocked-p *map*
                     (+ (entity/x player) (car move))
                     (+ (entity/y player) (cdr move)))
    (move player (car move) (cdr move))))
#+END_SRC

Now if you run the game, it should block you from walking through the walls!

*** Conclusion
That's all for this tutorial. Next we'll be working on procedurally generating
the dungeon map!

You can find the current state of the code on [[https://github.com/nwforrer/cl-rltut/tree/part-2][Github]]. The list of changes since
the previous tutorial can be found at
https://github.com/nwforrer/cl-rltut/compare/part-1...part-2.

If you run into any issues, or have questions/feedback, please open an issue on this
blogs [[https://github.com/nwforrer/blog/issues][GitHub repository]].

Continue to the [[/posts/roguelike-tutorial-part3][part 3]].
** DONE Roguelike tutorial for Common Lisp - Part 3 - Generating a dungeon :roguelike:gamedev:lisp:tutorial:
CLOSED: [2019-07-05 Fri 17:05]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part3
:END:
This tutorial series is based on the [[http://rogueliketutorials.com][Python Roguelike Tutorial]]. This will be
covering [[http://rogueliketutorials.com/tutorials/tcod/part-3/][Part 3]] of that tutorial.

In this post, we'll be procedurally generating the dungeon! We will generate
randomly sized rooms, and connect them with tunnels for the player and npcs to
walk around.

*** Looping over tiles
First things first, we're going to set all tiles to blocked by default.
Previously, we had all tiles set as floors, and placed a couple of walls to
test. Most dungeon generation algorithms work in the opposite way. They first
block all tiles, and then procedurally carve out rooms and corridors.

Update the initialize-tiles method to match the following:
#+BEGIN_SRC common-lisp
(defmethod initialize-tiles ((map game-map))
  (dotimes (y (game-map/h map))
    (dotimes (x (game-map/w map))
      (setf (aref (game-map/tiles map) x y) (make-instance 'tile :blocked t)))))
#+END_SRC

Looping over tiles like this is going to be something that happens a few times.
To make this easier, we can define a macro that will loop over all tiles (or a
subsection of tiles), and assign the current tile to a variable for us to use.
The macro looks like this:

#+BEGIN_SRC common-lisp
(defmacro map-tiles-loop ((map tile-val &key (row-val (gensym)) (col-val (gensym)) (x-start 0) (y-start 0) (x-end nil) (y-end nil)) &body body)
  `(loop :for ,col-val :from ,x-start :below (if (null ,x-end) (game-map/w ,map) ,x-end)
         :do
            (loop :for ,row-val :from ,y-start :below (if (null ,y-end) (game-map/h ,map) ,y-end)
                  :do
                     (let ((,tile-val (aref (game-map/tiles ,map) ,col-val ,row-val)))
                       (declare (ignorable ,tile-val))
                       ,@body))))
#+END_SRC

The macro takes in a map with all the tiles initialized, a tile-val which holds
the name you want to use for the variable that holds the current tile. It also
takes in some optional parameters via keys: row-val and col-val represent the
names of the x and y variables if you want to access them within the body of the
macro. If not supplied, they are generated. x-start, y-start, x-end, and y-end
allow you to specify the start and end of the tile array to loop over. By
default, it loops over all the tiles.

To see this in use, we can update the initialize-tiles method:
#+BEGIN_SRC common-lisp
(defmethod initialize-tiles ((map game-map))
  (map-tiles-loop (map tile :col-val x :row-val y)
    (setf (aref (game-map/tiles map) x y) (make-instance 'tile :blocked t))))
#+END_SRC

If we were to expand the macro, it looks like this:
#+BEGIN_SRC common-lisp
(loop :for x :from 0 :below (if (null nil)
                                  (game-map/w map)
                                  nil)
        :do (loop :for y :from 0 :below (if (null nil)
                                            (game-map/h map)
                                            nil)
                  :do (let ((tile (aref (game-map/tiles map) x y)))
                        (declare (ignorable tile))
                        (setf (aref (game-map/tiles map) x y)
                                (make-instance 'tile :blocked
                                               initial-blocked-value)))))
#+END_SRC

*** Defining rooms and tunnels

Before we get into the map generation, let's create a helper class that we'll
use to represent rooms:
#+BEGIN_SRC common-lisp
(defclass rect ()
  ((x1 :initarg :x1 :accessor rect/x1)
   (x2 :initarg :x2 :accessor rect/x2)
   (y1 :initarg :y1 :accessor rect/y1)
   (y2 :initarg :y2 :accessor rect/y2)))

(defmethod initialize-instance :after ((rect rect) &key x y w h)
  (with-slots (x1 x2 y1 y2) rect
    (setf x1 x
          y1 y
          x2 (+ x w)
          y2 (+ y h))))
#+END_SRC

rect holds the values to represent the top left and bottom right corners of the
rectangle. We also defined the initialize-instance method for the class, and
allowed x y w h to be passed in, making it easier to create an instance of the class.

Now we can carve rooms into the map:
#+BEGIN_SRC common-lisp
(defmethod set-tile-slots ((tile tile) &key (blocked nil blocked-supplied-p) (block-sight nil block-sight-supplied-p))
  (if blocked-supplied-p
      (setf (slot-value tile 'blocked) blocked))
  (if block-sight-supplied-p
      (setf (slot-value tile 'block-sight) block-sight)))

(defmethod create-room ((map game-map) (room rect))
  (map-tiles-loop (map tile
                   :x-start (1+ (rect/x1 room)) :x-end (rect/x2 room)
                   :y-start (1+ (rect/y1 room)) :y-end (rect/y2 room))
    (set-tile-slots tile :blocked nil :block-sight nil)))
#+END_SRC

We make sure to leave the border of the room untouched, which is why the loop
starts at x1/y1 + 1, and the ending x2/y2 is excluded (remember, the
map-tiles-loop macro uses :below in the loop). This ensures that if we make two
rooms next to each other, one starting at (1,1) going to (6,6), and the other
starting at (7,1) going to (9,6) there will still be a wall in between them.
Otherwise, it would look like one room instead of two rooms.

Now, let's make a couple rooms to test. Create the following method:
#+BEGIN_SRC common-lisp
(defmethod make-map ((map game-map))
  (let ((room-1 (make-instance 'rect :x 20 :y 15 :w 10 :h 15))
        (room-2 (make-instance 'rect :x 35 :y 15 :w 10 :h 15)))
    (create-room map room-1)
    (create-room map room-2)))
#+END_SRC

In order to call this method in our main function, we're going to update our
game loop structure a bit. We'll add a new game-tick function, and update the main function to look like this:
#+BEGIN_SRC common-lisp
(defun game-tick (player entities map)
  (render-all entities map)
  (let* ((action (handle-keys))
         (move (getf action :move))
         (exit (getf action :quit)))
    (when move
      (unless (blocked-p map
                         (+ (entity/x player) (car move))
                         (+ (entity/y player) (cdr move)))
        (move player (car move) (cdr move))))

    exit))

(defun main ()
  (blt:with-terminal
      (config)
    (let ((player (make-instance 'entity
                                  :x (/ *screen-width* 2)
                                  :y (/ *screen-height* 2)
                                  :char #\@
                                  :color (blt:white)))
          (npc (make-instance 'entity
                               :x (- (/ *screen-width* 2) 5)
                               :y (/ *screen-height* 2)
                               :char #\@
                               :color (blt:yellow)))
          (entities (list player npc))
          (map (make-instance 'game-map :w *map-width* :h *map-height*)))
      (make-map (map))

      (do ((exit nil (game-tick player entities map)))
          (exit)))))
#+END_SRC

You can also remove the *map* global variable we had before, as we now create
the map locally. While we're at it, we don't really need the initialize-tiles method in the
game-map.lisp file. Since we always want the tiles initialized, we'll move that
code into the initialize-instance method:
#+BEGIN_SRC common-lisp
(defmethod initialize-instance :after ((map game-map) &key (initial-blocked-value t))
  (setf (game-map/tiles map) (make-array (list (game-map/w map) (game-map/h map))))
  (map-tiles-loop (map tile :col-val x :row-val y)
                  (setf (aref (game-map/tiles map) x y) (make-instance 'tile :blocked initial-blocked-value))))
#+END_SRC

Now if you run the game, it should look like this:
[[/cl-rltut/create-test-rooms.png]]

With the rooms being created, we should also create tunnels to connect them.
For our generation code, the tunnels will just be a combination of a horizontal
and vertical section, so there won't be any winding tunnels. Add the following
two methods:
#+BEGIN_SRC common-lisp
(defmethod create-h-tunnel ((map game-map) x1 x2 y)
  (let ((start-x (min x1 x2))
        (end-x (max x1 x2)))
    (map-tiles-loop (map tile
                     :x-start start-x :x-end (1+ end-x)
                     :y-start y :y-end (1+ y))
      (set-tile-slots tile :blocked nil :block-sight nil))))

(defmethod create-v-tunnel ((map game-map) y1 y2 x)
  (let ((start-y (min y1 y2))
        (end-y (max y1 y2)))
    (map-tiles-loop (map tile
                     :x-start x :x-end (1+ x)
                     :y-start start-y :y-end (1+ end-y))
      (set-tile-slots tile :blocked nil :block-sight nil))))
#+END_SRC

Let's test it out by updating our make-map method:
#+BEGIN_SRC common-lisp
(defmethod make-map ((map game-map))
  (let ((room-1 (make-instance 'rect :x 20 :y 15 :w 10 :h 15))
        (room-2 (make-instance 'rect :x 35 :y 15 :w 10 :h 15)))
    (create-room map room-1)
    (create-room map room-2))

  (create-h-tunnel map 25 40 23))
#+END_SRC

Running the game now should look like:
[[/cl-rltut/test-tunnel.png]]
*** Generating the dungeon
Now that we can create rooms and tunnels, it's time to move on to the actual
dungeon generation. It will be relatively basic: we'll create a bunch of rooms,
make sure they don't overlap, and connect them together.

First, add a couple methods to the rect class to assist with detecting when two
rooms overlap:
#+BEGIN_SRC common-lisp
(defmethod center ((rect rect))
  (with-slots (x1 x2 y1 y2) rect
    (let ((center-x (round (/ (+ x1 x2) 2)))
          (center-y (round (/ (+ y1 y2) 2))))
      (values center-x center-y))))

(defmethod intersect ((rect rect) (other rect))
  "Returns T if this RECT intersects with OTHER"
  (and (<= (rect/x1 rect) (rect/x2 other))
       (>= (rect/x2 rect) (rect/x1 other))
       (<= (rect/y1 rect) (rect/y2 other))
       (>= (rect/y2 rect) (rect/y1 other))))
#+END_SRC

Add a couple of variables to the cl-rltut.lisp file, to use with our generation:
#+BEGIN_SRC common-lisp
(defparameter *room-max-size* 10)
(defparameter *room-min-size* 6)
(defparameter *max-rooms* 30)
#+END_SRC

Now, update the make-map method signature to take in those variables, and start
calculating the position and size for the rooms:
#+BEGIN_SRC common-lisp
(defmethod make-map ((map game-map) max-rooms room-min-size room-max-size map-width map-height player)
  (do* ((rooms nil)
        (num-rooms 0)
        (room-index 0 (1+ room-index))
        (w (+ (random (- room-max-size room-min-size)) room-min-size)
           (+ (random (- room-max-size room-min-size)) room-min-size))
        (h (+ (random (- room-max-size room-min-size)) room-min-size)
           (+ (random (- room-max-size room-min-size)) room-min-size))
        (x (random (- map-width w))
           (random (- map-width w)))
        (y (random (- map-height h))
           (random (- map-height h)))
        (new-room (make-instance 'rect :x x :y y :w w :h h)
                  (make-instance 'rect :x x :y y :w w :h h))
        (can-place-p t t))
       ((>= room-index max-rooms))))
#+END_SRC

We're calculating each room's width and height as a random size between the
room-min-size and room-max-size. The x and y position is a random point within
the map. We then create a new-room variable with these calculated values. The
rooms variable is going to hold all the rooms that we create, so we can check
for overlaps, and the room-index and num-rooms will help with looking up the
previous room. When we generate the tunnels, we'll just be connecting the
current room to the previously created room.

Update the do* body to check for intersections:
#+BEGIN_SRC common-lisp
(dolist (other-room rooms)
  (if (intersect new-room other-room)
      (setf can-place-p nil)))
#+END_SRC

That just loops over the rooms list (which we'll populate later), and checks if
the current room we're placing intersects with any of the other rooms. If there
is an intersection, we're setting the can-place-p variable to show that we
shouldn't actually create this room.

After that dolist loop, we can create the new room, and connect it to the
previous room:
#+BEGIN_SRC common-lisp
(when can-place-p
  (create-room map new-room)
  (multiple-value-bind (new-x new-y) (center new-room)
    (if (zerop num-rooms)
        (setf (entity/x player) new-x
              (entity/y player) new-y)
        (multiple-value-bind (prev-x prev-y) (center (car (last rooms)))
          (cond ((= (random 2) 1)
                 (create-h-tunnel map prev-x new-x prev-y)
                 (create-v-tunnel map prev-y new-y new-x))
                (t
                 (create-v-tunnel map prev-y new-y prev-x)
                 (create-h-tunnel map prev-x new-x new-y)))))
    (if (null rooms)
        (setf rooms (list new-room))
        (push new-room (cdr (last rooms))))
    (incf num-rooms)))
#+END_SRC

The tunnel creation randomly decides whether to use a horizontal or vertical
tunnel first, so that it doesn't look so uniform. The tunnel is created from the
center of the previous room, to the center of the new room. After the room is
created, it's added to the rooms list so that we can check for overlaps in the
next rooms.

Running the code now, you should see a complete dungeon:
[[/cl-rltut/dungeon-generation.png]]

Note that since it's randomly generated, your output won't look exactly the same.

*** Conclusion
That's all there is to it. It's a pretty simple algorithm, but gives decent
results. There are plenty of other algorithms to generate different looking
dungeons. For example, you can use a type of [[http://journal.stuffwithstuff.com/2014/12/21/rooms-and-mazes/][maze algorithm]] to make the tunnels
between rooms more interesting.

You can find the current state of the code on [[https://github.com/nwforrer/cl-rltut/tree/part-3][Github]]. The list of changes since
the previous tutorial can be found at
[[https://github.com/nwforrer/cl-rltut/compare/part-2...part-3]].

If you run into any issues, or have questions/feedback, please open an issue on this
blogs [[https://github.com/nwforrer/blog/issues][GitHub repository]].

Continue to [[/posts/roguelike-tutorial-part4][part 4]].
** DONE Roguelike tutorial for Common Lisp - Part 4 - Field of view :roguelike:gamedev:lisp:tutorial:
CLOSED: [2019-07-14 Sun 22:43]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part4
:END:
This tutorial series is based on the [[http://rogueliketutorials.com][Python Roguelike Tutorial]]. This will be
covering [[http://rogueliketutorials.com/tutorials/tcod/part-4/][Part 4]] of that tutorial.

In this post, we'll be computing the Field Of View (FOV) of the player. This
will make exploring the dungeon much more interesting. When the game starts,
only the tiles near the player will be visible. As the player explores the
dungeon, the tiles that the player moves past will also become visible, allowing
the map to be shown. However, any items or enemies will only be visible if they
are within the players sight at a given time. Once the player moves on, the
item/enemy will no longer be displayed.

This post will differ from the Python Roguelike Tutorial more-so than previous
posts. In the Python Tutorial, the libtcod library is being used, which provides
FOV algorithms to calculate the FOV for you. However, we're using
BearLibTerminal which does not have such algorithms. We could import the libtcod
library to take advantage of those algorithms, but where's the fun in that?
Instead we'll be writing the algorithm from scratch. The reference I'm using
for this is:
[[http://www.roguebasin.com/index.php?title=Line_of_Sight_-_Tobias_Downer][http://www.roguebasin.com/index.php?title=Line_of_Sight_-_Tobias_Downer]].
RogueBasin has many [[http://www.roguebasin.com/index.php?title=Category:FOV][articles and techniques]] for calculating the FOV. We'll be
taking a very simplistic approach, which will work well enough for our needs.

*** Calculating the Field of View
First, we'll need a way to track which tiles are visible to the player, so that
we can render them differently from the non-visible tiles:
#+BEGIN_SRC common-lisp
(defclass tile ()
  ((blocked :initarg :blocked
            :accessor tile/blocked
            :initform nil)
   (block-sight :initarg :block-sight
                :accessor tile/block-sight
                :initform nil)
   (visible :initarg :visible
            :accessor tile/visible
            :initform nil)))
#+END_SRC

The way the algorithm works, is we'll start at the player's position, trace rays
in every direction, and check each tile that the ray intersects with. If the
tile's block-sight slot is set to nil, then we'll set it's visible slot to t.
Once a ray reaches a tile that has block-site set to t, then we stop tracing
that ray, so all the tiles after it have their visible tiles set to nil.

Create a new file named fov.lisp, and create a fov function, and a way to reset
the visible slot on all tiles:
#+BEGIN_SRC common-lisp
(defparameter *fov-distance* 5)

(defun reset-visibility (map)
  (map-tiles-loop (map tile)
    (setf (tile/visible tile) nil)))

(defun fov (map x y)
  (reset-visibility map))
#+END_SRC

Now, we'll trace 360 lines around the player's position, one for each degree of
a circle. Each line will be `fov-distance` long. We will use [[https://en.wikipedia.org/wiki/Linear_interpolation][linear
interpolation]] to take incremential steps over the line. At each step, we'll
check that we haven't gone outside the bounds of the map, and then check if the
tile at that step has block-sight set to t. If neither of those are true, then
the tile must be visible. The full function looks like this:
#+BEGIN_SRC common-lisp
(defun degree-to-radian (degree)
  (* degree (/ pi 180)))

(defun diagonal-distance (x0 y0 x1 y1)
  (let ((dx (- x0 x1))
        (dy (- y1 y0)))
    (max (abs dx) (abs dy))))

(defun lerp (start end time)
  (+ start (* time (- end start))))

(defun fov (map x y)
  (reset-visibility map)

  ;; loop aver 360 degrees
  (dotimes (degree 360)
    (let* ((rad (degree-to-radian degree))
           (nx (round (+ (* (cos rad) *fov-distance*) x)))
           (ny (round (+ (* (sin rad) *fov-distance*) y)))
           (d (diagonal-distance x y nx ny)))
      (dotimes (tile d)
        (let ((tx (round (lerp x nx (/ tile d))))
              (ty (round (lerp y ny (/ tile d)))))
          (if (or (< tx 0) (> tx (game-map/w map)))
              (return))
          (if (or (< ty 0) (> ty (game-map/h map)))
              (return))

          ;; if tile is a wall, mark as seen and stop the line early
          (when (tile/block-sight (aref (game-map/tiles map) tx ty))
            (setf (tile/visible (aref (game-map/tiles map) tx ty)) t)
            (return))

          (setf (tile/visible (aref (game-map/tiles map) tx ty)) t))))))
#+END_SRC

*** Rendering the field of view
Now that we know which tiles are visible to the player, we can update our
rendering to display them differently. Update the color map to include the
colors we'll use to display the visible floors and walls:
#+BEGIN_SRC common-lisp
(defparameter *color-map* (list :dark-wall (blt:rgba 0 0 100)
                                :dark-ground (blt:rgba 50 50 150)
                                :light-wall (blt:rgba 130 110 50)
                                :light-ground (blt:rgba 200 180 50)))
#+END_SRC

Now we can update the render-all function to change the tile colors depending on
whether the tile is visible or not:
#+BEGIN_SRC common-lisp
(defun render-all (entities map)
  (blt:clear)
  (dotimes (y *map-height*)
    (dotimes (x *map-width*)
      (let* ((tile (aref (game-map/tiles map) x y))
             (wall (tile/block-sight tile))
             (visible (tile/visible tile)))
        (if visible
            (if wall
                (setf (blt:background-color) (getf *color-map* :light-wall))
                (setf (blt:background-color) (getf *color-map* :light-ground)))
            (if wall
                (setf (blt:background-color) (getf *color-map* :dark-wall))
                (setf (blt:background-color) (getf *color-map* :dark-ground)))))))
  (mapc #'(lambda (entity) (draw entity map)) entities)
  (setf (blt:background-color) (blt:black))
  (blt:refresh))
#+END_SRC

Now if you run the game, you should see something like this:
[[/cl-rltut/display-fov.png]]

*** Exploration
One issue with how this works is the entire map is visible to the player at the
start. We'd rather hide the map, and only start to display it as the player
explores. To do that, we'll add another tile slot to track which tiles have been
explored, and then mark that `t` whenever the tile becomes visible. The
difference between `explored` and `visible` is that once `explored` is set to t,
it will not be reset.
#+BEGIN_SRC common-lisp
(defclass tile ()
  ((blocked :initarg :blocked
            :accessor tile/blocked
            :initform nil)
   (block-sight :initarg :block-sight
                :accessor tile/block-sight
                :initform nil)
   (visible :initarg :visible
            :accessor tile/visible
            :initform nil)
   (explored :initarg :explored
             :accessor tile/explored
             :initform nil)))
#+END_SRC

Now in the fov function, whenever the visible slot is set to true, also set the
explored slot to t:
#+BEGIN_SRC common-lisp
(when (tile/block-sight (aref (game-map/tiles map) tx ty))
  (setf (tile/visible (aref (game-map/tiles map) tx ty)) t
        (tile/explored (aref (game-map/tiles map) tx ty)) t)
  (return))

(setf (tile/visible (aref (game-map/tiles map) tx ty)) t
      (tile/explored (aref (game-map/tiles map) tx ty)) t)
#+END_SRC

With that data being tracked, we can update the renderer to only show visible or
explored tiles.
#+BEGIN_SRC common-lisp
(defun render-all (entities map)
  (blt:clear)
  (dotimes (y *map-height*)
    (dotimes (x *map-width*)
      (let* ((tile (aref (game-map/tiles map) x y))
             (wall (tile/block-sight tile))
             (visible (tile/visible tile))
             (explored (tile/explored tile)))
        (cond (visible
               (if wall
                   (setf (blt:background-color) (getf *color-map* :light-wall))
                   (setf (blt:background-color) (getf *color-map* :light-ground)))
               (setf (blt:cell-char x y) #\Space))
              (explored
               (if wall
                   (setf (blt:background-color) (getf *color-map* :dark-wall))
                   (setf (blt:background-color) (getf *color-map* :dark-ground)))
               (setf (blt:cell-char x y) #\Space))))))
  (mapc #'(lambda (entity) (draw entity map)) entities)
  (setf (blt:background-color) (blt:black))
  (blt:refresh))
#+END_SRC

The last step we'll want to do is to also update the entity draw method. We'll
only want to draw entities that the player can see:
#+BEGIN_SRC common-lisp
(defmethod draw ((e entity) (map game-map))
  (with-slots (x y char color) e
    (if (tile/visible (aref (game-map/tiles map) x y))
        (setf
         (blt:background-color) (blt:cell-background-color x y)
         (blt:color) color
         (blt:cell-char x y) char))))
#+END_SRC

Now if you run the game, you should see something like this:
[[/cl-rltut/dungeon-exploration.gif]]

*** Conclusion
That's all there is to it. If you're interested in other more efficient
algorithms, I'd recommend checking out the [[http://www.roguebasin.com/index.php?title=Category:FOV][FOV section on RogueBasin]].

You can find the current state of the code on [[https://github.com/nwforrer/cl-rltut/tree/part-4][Github]]. The list of changes since
the previous tutorial can be found at
[[https://github.com/nwforrer/cl-rltut/compare/part-3...part-4]].

If you run into any issues, or have questions/feedback, please open an issue on this
blogs [[https://github.com/nwforrer/blog/issues][GitHub repository]].

Continue to [[/posts/roguelike-tutorial-part5][part 5]].
** DONE Roguelike tutorial for Common Lisp - Part 5 - Placing enemies :roguelike:gamedev:lisp:tutorial:
CLOSED: [2019-07-15 Mon 23:19]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part5
:END:
This tutorial series is based on the [[http://rogueliketutorials.com][Python Roguelike Tutorial]]. This will be
covering [[http://rogueliketutorials.com/tutorials/tcod/part-5/][Part 5]] of that tutorial.

In this post, we'll start adding enemies to the dungeon. We won't be getting
into the combat system yet, but we'll get collision detection and turn-based
movement working.

*** Placing enemies
We'll start by randomly placing enemies during the dungeon generation. Add a
`place-entities` method in the game-map.lisp file:
#+BEGIN_SRC common-lisp
(defun entity-at (entities x y)
  (dolist (entity entities)
    (if (and (= (entity/x entity) x)
             (= (entity/y entity) y))
        (return entity))))

(defmethod place-entities ((map game-map) (room rect) entities max-enemies-per-room)
  (let ((num-monsters (random max-enemies-per-room)))
    (dotimes (monster-index num-monsters)
      (let ((x (+ (random (round (/ (- (rect/x2 room) (rect/x1 room) 1) 2))) (1+ (rect/x1 room))))
            (y (+ (random (round (/ (- (rect/y2 room) (rect/y1 room) 1) 2))) (1+ (rect/y1 room)))))
        (unless (entity-at entities x y)
          (if (< (random 100) 80)
              (nconc entities (list (make-instance 'entity :x x :y y :color (blt:green) :char #\o)))
              (nconc entities (list (make-instance 'entity :x x :y y :color (blt:yellow) :char #\T)))))))))
#+END_SRC
We choose a random number of entities to generate, from 0 up to the
max-enemies-per-room passed in. We then chose a random x and y position, within
the passed in room boundaries. Then, as long as there isn't already an enemy at
the chosen position, we'll place a new enemy. We'll randomly choose between two
different enemies, an orc or a troll. It will be an 80% chance to spawn an Orc,
which will be the weaker enemy.

Call this new method after creating each room in the `make-map` method. The
method will also need to take in two new parameters: the entities list, and the max-enemies-per-room.
#+BEGIN_SRC common-lisp
(defmethod make-map ((map game-map) max-rooms room-min-size room-max-size map-width map-height player entities max-enemies-per-room)
  (do* ((rooms nil)
        (num-rooms 0)
        (room-index 0 (1+ room-index))
        (w (+ (random (- room-max-size room-min-size)) room-min-size)
           (+ (random (- room-max-size room-min-size)) room-min-size))
        (h (+ (random (- room-max-size room-min-size)) room-min-size)
           (+ (random (- room-max-size room-min-size)) room-min-size))
        (x (random (- map-width w))
           (random (- map-width w)))
        (y (random (- map-height h))
           (random (- map-height h)))
        (new-room (make-instance 'rect :x x :y y :w w :h h)
                  (make-instance 'rect :x x :y y :w w :h h))
        (can-place-p t t))
       ((>= room-index max-rooms))
    (dolist (other-room rooms)
      (if (intersect new-room other-room)
          (setf can-place-p nil)))
    (when can-place-p
      (create-room map new-room)
      (multiple-value-bind (new-x new-y) (center new-room)
        (if (zerop num-rooms)
            (setf (entity/x player) new-x
                  (entity/y player) new-y)
            (multiple-value-bind (prev-x prev-y) (center (car (last rooms)))
              (cond ((= (random 2) 1)
                     (create-h-tunnel map prev-x new-x prev-y)
                     (create-v-tunnel map prev-y new-y new-x))
                    (t
                     (create-v-tunnel map prev-y new-y prev-x)
                     (create-h-tunnel map prev-x new-x new-y)))))
        (place-entities map new-room entities max-enemies-per-room)
        (if (null rooms)
            (setf rooms (list new-room))
            (push new-room (cdr (last rooms))))
        (incf num-rooms)))))
#+END_SRC

Since the method signature has been updated, we'll need to update the call from
our main function:
#+BEGIN_SRC common-lisp
(make-map map *max-rooms* *room-min-size* *room-max-size* *map-width* *map-height* player entities *max-enemies-per-room*)
#+END_SRC

The temporary npc we were using before can be deleted now as well.

If you run the game, you should now see enemies spawning in rooms:
[[/cl-rltut/placing-enemies.png]]

*** Colliding with enemies
If you move around in the game now, you'll notice that you can walk right
through the enemies. We'll want to make sure that when you try to walk into
them, you'll collide. Eventually, colliding with enemies should make you attack,
but that will come later. For now, we'll stop the movement and print out a
message.

First, we'll add a `blocks` slot to the entity class. We'll also add a `name`
slot while we're here, which we can use when printing entity information:
#+BEGIN_SRC common-lisp
(defclass entity ()
  ((name :initarg :name :accessor entity/name)
   (x :initarg :x :accessor entity/x)
   (y :initarg :y :accessor entity/y)
   (char :initarg :char :accessor entity/char)
   (color :initarg :color :accessor entity/color)
   (blocks :initarg :blocks :accessor entity/blocks)))
#+END_SRC

Now, update everywhere an entity is created, to supply this additional
information (creating the player, and the enemies)
The player will look like this:
#+BEGIN_SRC common-lisp
(make-instance 'entity
               :name "Player"
               :x (/ *screen-width* 2)
               :y (/ *screen-height* 2)
               :char #\@
               :color (blt:white)
               :blocks t)
#+END_SRC
The enemies will look like this:
#+BEGIN_SRC common-lisp
(make-instance 'entity :name "Orc" :x x :y y :color (blt:green) :char #\o :blocks t)
(make-instance 'entity :name "Troll" :x x :y y :color (blt:yellow) :char #\T :blocks t)
#+END_SRC

We'll need a way to check whether a blocking entity exists in a specific
position on the map. Add a `blocking-entity-at` function, which will return the
entity that is found, or nil otherwise:
#+BEGIN_SRC common-lisp
(defun blocking-entity-at (entities x y)
  (dolist (entity entities)
    (if (and (= (entity/x entity) x)
             (= (entity/y entity) y)
             (entity/blocks entity))
        (return entity))))
#+END_SRC

Now, we can update the player movement code to check for enemy collisions when
moving. To do this, we'll check whether the tile that the player will be moving
to contains a blocking entity. If it does, we won't move the player, and we'll
print out a message instead. Update the movement check in the `game-tick` function:
#+BEGIN_SRC common-lisp
(when move
  (let ((destination-x (+ (entity/x player) (car move)))
        (destination-y (+ (entity/y player) (cdr move))))
    (unless (blocked-p map destination-x destination-y)
      (let ((target (blocking-entity-at entities destination-x destination-y)))
        (cond (target
               (format t "You kick the ~A.~%" (entity/name target)))
              (t
               (move player (car move) (cdr move))
               (fov map (entity/x player) (entity/y player))))))))
#+END_SRC

Now if you run the game, you'll collide with enemies, and see messages printed
out with the name of the entity that you collided with.

*** Taking turns
The final change we'll make in this post is to introduce "turns". Right now, the
player can move whenever they want. However, the game is turn based, so will
need to let the enemies take their turns after the player. To do this, we'll
keep track of whose turn it is (the player or the enemies), and only let them
perform any action if it's their turn.

Add a type definition to hold the various states for the game:
#+BEGIN_SRC common-lisp
(deftype game-states () '(member :player-turn :enemy-turn :exit))
#+END_SRC

Update the `game-tick` function to track and update the game-state. When the
state is `:player-turn`, we'll let the player move and then set the state to
`:enemy-turn`. When the state is `:enemy-turn`, we'll loop through all of the
enemies, and let them take a turn. For now, an enemy will just print something
out when taking a turn, but later on we'll introduce enemy AI. We're also going
to be using the game-state to track when the game will exit, rather than
returning a boolean from the game-tick function.
#+BEGIN_SRC common-lisp
(defun game-tick (player entities map game-state)
  (declare (type game-states game-state))
  (render-all entities map)
  (let* ((action (handle-keys))
         (move (getf action :move))
         (exit (getf action :quit)))
    (when (and move (eql game-state :player-turn))
      (let ((destination-x (+ (entity/x player) (car move)))
            (destination-y (+ (entity/y player) (cdr move))))
        (unless (blocked-p map destination-x destination-y)
          (let ((target (blocking-entity-at entities destination-x destination-y)))
            (cond (target
                   (format t "You kick the ~A.~%" (entity/name target)))
                  (t
                   (move player (car move) (cdr move))
                   (fov map (entity/x player) (entity/y player)))))
          (setf game-state :enemy-turn))))
    (when exit
      (setf game-state :exit)))

  (when (eql game-state :enemy-turn)
    (dolist (entity entities)
      (if (not (eql player entity))
          (format t "The ~A sits idly.~%" (entity/name entity))))
    (setf game-state :player-turn))

  game-state)
#+END_SRC

If you run the game now, when you move, you'll see all enemies that have been
spawned in the dungeon print something out. Each time you move, you'll see the
print statements.

*** Conclusion
That's all there is for now. In the next post we'll be focusing on the combat
system, now that we have enemies to attack.

You can find the current state of the code on [[https://github.com/nwforrer/cl-rltut/tree/part-5][Github]]. The list of changes since
the previous tutorial can be found at
[[https://github.com/nwforrer/cl-rltut/compare/part-4...part-5]].

If you run into any issues, or have questions/feedback, please open an issue on this
blogs [[https://github.com/nwforrer/blog/issues][GitHub repository]].

Continue to [[/posts/roguelike-tutorial-part6][part 6]].
** DONE Roguelike tutorial for Common Lisp - Part 6 - Combat :roguelike:gamedev:lisp:tutorial:
CLOSED: [2019-10-16 Wed 06:55]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part6
:END:
This tutorial series is based on the [[http://rogueliketutorials.com][Python Roguelike Tutorial]]. This will be
covering [[http://rogueliketutorials.com/tutorials/tcod/part-6/][Part 6]] of that tutorial.

In this part, we will be adding a combat system, allowing players to kill monsters,
as well as be killed. To accomplish this, we will also be adding a component
system, and implementing an A* pathfinding algorithm. This will be a
relatively long post, so let's get right into it.

*** Components
For any enemies that can fight and take damage, we'll be creating a fighter
"component," which will contain the entities hp, attack, and defense. This is
known as "composition," rather than inheritance. In an inheritance model, we
would likely have created a new Fighter class that inherits from the Entity
class. These types of hierarchies can start out fine, but will quickly become
difficult to work with.

Create a new file, components.lisp, with the new component and fighter classes:
#+BEGIN_SRC lisp
(in-package :cl-rltut)

(defclass component ()
  ((owner :initarg :owner :accessor component/owner)))

(defclass fighter (component)
  ((max-hp :initarg :max-hp :accessor fighter/max-hp :initform nil)
   (hp :initarg :hp :accessor fighter/hp)
   (defense :initarg :defense :accessor fighter/defense)
   (power :initarg :power :accessor fighter/power)))
#+END_SRC

We'll also be creating a component to represent an enemies AI behavior, along
with a "take-turn" method to execute the behavior:

#+BEGIN_SRC lisp
(defclass basic-monster (component) ())

(defgeneric take-turn (component))

(defmethod take-turn ((component basic-monster))
  (format t "The ~A wonders when it will get to move." (component/owner component)))
#+END_SRC

New we need to add slots to the "entity" class to hold the two new components.
They will be optional, since not all entities will have the components. We'll
also need to set the "owner" slot on the components to the entity that they are
being attached to, so that the components can get information for their entity,
such as the entity position.

#+BEGIN_SRC lisp -n :hl_lines 8-9, 11-17
(defclass entity ()
  ((name :initarg :name :accessor entity/name)
   (x :initarg :x :accessor entity/x)
   (y :initarg :y :accessor entity/y)
   (char :initarg :char :accessor entity/char)
   (color :initarg :color :accessor entity/color)
   (blocks :initarg :blocks :accessor entity/blocks)
   (fighter :initarg :fighter :accessor entity/fighter :initform nil)
   (ai :initarg :ai :accessor entity/ai :initform nil)))

(defmethod initialize-instance :after ((entity entity) &rest initargs)
  (declare (ignore initargs))
  (with-slots (fighter ai) entity
    (when fighter
      (setf (component/owner fighter) entity))
    (when ai
      (setf (component/owner ai) entity))))
#+END_SRC

Now, when creating the player entity, we'll want to create a fighter component
to add (in the main function in cl-rltut.lisp):
#+BEGIN_SRC lisp -n :hl_lines 2-5,13
...
(let* ((fighter-component (make-instance 'fighter
                                         :hp 30
                                         :defense 2
                                         :power 5))
       (player (make-instance 'entity
                              :name "Player"
                              :x (/ *screen-width* 2)
                              :y (/ *screen-height* 2)
                              :char #\@
                              :color (blt:white)
                              :blocks t
                              :fighter fighter-component))
       (entities (list player))
       (map (make-instance 'game-map :w *map-width* :h *map-height*)))
  ...)
#+END_SRC

And we'll do the same for the monsters (in the place-entities function in
game-map.lisp):
#+BEGIN_SRC lisp -n :hl_lines 8-9,11,14-15,17
(defmethod place-entities ((map game-map) (room rect) entities max-enemies-per-room)
  (let ((num-monsters (random max-enemies-per-room)))
    (dotimes (monster-index num-monsters)
      (let ((x (+ (random (round (/ (- (rect/x2 room) (rect/x1 room) 1) 2))) (1+ (rect/x1 room))))
            (y (+ (random (round (/ (- (rect/y2 room) (rect/y1 room) 1) 2))) (1+ (rect/y1 room)))))
        (unless (entity-at entities x y)
          (cond ((< (random 100) 80)
                 (let* ((fighter-component (make-instance 'fighter :hp 10 :defense 0 :power 3))
                        (ai-component (make-instance 'basic-monster))
                        (orc (make-instance 'entity :name "Orc" :x x :y y :color (blt:green) :char #\o :blocks t
                                                    :fighter fighter-component :ai ai-component)))
                   (nconc entities (list orc))))
                (t
                 (let* ((fighter-component (make-instance 'fighter :hp 16 :defense 1 :power 4))
                        (ai-component (make-instance 'basic-monster))
                        (troll (make-instance 'entity :name "Troll" :x x :y y :color (blt:yellow) :char #\T :blocks t
                                                      :fighter fighter-component :ai ai-component)))
                   (nconc entities (list troll))))))))))
#+END_SRC

Now we can update the game loop to call the take-turn function on all the
entities with the AI component:
#+BEGIN_SRC lisp -n
(when (eql (game-state/state game-state) :enemy-turn)
  (dolist (entity (remove-if-not #'entity/ai entities))
    (take-turn (entity/ai entity)))
  (setf (game-state/state game-state) :player-turn))
#+END_SRC

You can now run the game again. The only difference you'll see is the message
being printed out by the monsters is different, but we've set up a working
component system. Next we'll want to update the AI component to move towards the
player and attack.

*** Basic monster AI
Add a "move-towards" method to the entity class, which will move an the entity
towards a target location. It will only move in a straight line towards the
target, and stop if it hits a wall. We'll add pathfinding a little later.
#+BEGIN_SRC lisp
(defgeneric move-towards (e target-x target-y map entities))

(defmethod move-towards ((e entity) target-x target-y map entities)
  (with-slots (x y) e
    (let* ((dx (- target-x x))
           (dy (- target-y y))
           (distance (sqrt (+ (expt dx 2) (expt dy 2)))))
      (setf dx (round (/ dx distance))
            dy (round (/ dy distance)))
      (unless (or (blocked-p map (+ x dx) (+ y dy))
                  (blocking-entity-at entities (+ x dx) (+ y dy)))
        (move e dx dy)))))

#+END_SRC

Also add a "distance-to" method, which we'll use to decide whether a monster is
close enough to attack the player:
#+BEGIN_SRC lisp
(defmethod distance-to ((e entity) (other entity))
  (let ((dx (- (entity/x other) (entity/x e)))
        (dy (- (entity/y other) (entity/y e))))
    (sqrt (+ (expt dx 2) (expt dy 2)))))
#+END_SRC

Now update the "take-turn" method to move towards the player. We'll move the
monster as long as it's within the FOV of the player. If the monster is one tile
away from the player, then print out an attack message.
#+BEGIN_SRC lisp
(defgeneric take-turn (component target map entities))

(defmethod take-turn ((component basic-monster) target map entities)
  (let* ((monster (component/owner component))
         (in-sight (tile/visible (aref (game-map/tiles map) (entity/x monster) (entity/y monster)))))
    (when in-sight
      (cond ((>= (distance-to monster target) 2)
             (move-towards monster (entity/x target) (entity/y target) map entities))
            ((> (fighter/hp (entity/fighter target)) 0)
             (format t "The ~A insults you! Your ego is damaged!" (entity/name monster)))))))
#+END_SRC

We'll also need to update the call to "take-turn" to pass in the target, map,
and entities parameters.
#+BEGIN_SRC lisp
(when (eql (game-state/state game-state) :enemy-turn)
  (dolist (entity (remove-if-not #'entity/ai entities))
    (take-turn (entity/ai entity) player map entities))
  (setf (game-state/state game-state) :player-turn))
#+END_SRC

Now you can run the game, and the enemies will chase you. When they get close
enough they'll print out a message insulting you.

Currently, the monsters are able to attack the player from a diagonal position,
but the player can only attack up/down/left/right, and both the player and
monsters can only move in four directions. We can either stop the monsters from
attacking diagonally, or allow all entities to attack and move in eight
directions. We'll implement the latter. First, let's allow the player to move in
eight directions. We'll use the "vim keys" for movement. Update the
"handle-keys" function as follows:
#+BEGIN_SRC lisp -n
(defun handle-keys ()
  (when (blt:has-input-p)
    (blt:key-case (blt:read)
                  ((or :up :k) (list :move (cons 0 -1)))
                  ((or :down :j) (list :move (cons 0 1)))
                  ((or :left :h) (list :move (cons -1 0)))
                  ((or :right :l) (list :move (cons 1 0)))
                  (:y (list :move (cons -1 -1)))
                  (:u (list :move (cons 1 -1)))
                  (:b (list :move (cons -1 1)))
                  (:n (list :move (cons 1 1)))
                  (:escape (list :quit t))
                  (:close (list :quit t)))))
#+END_SRC

*** A-star Pathfinding
Now, we'll want to allow the enemies to move in eight directions. To do this,
we'll need to implement a pathfinding algorithm called "A* (A-star)." Red Blob Games
as a great [[https://www.redblobgames.com/pathfinding/a-star/introduction.html][introduction to A*]], as well as an [[https://www.redblobgames.com/pathfinding/a-star/implementation.html][implementation guide]] for
Python, C++, and C#. For my implementation, I used [[https://medium.com/@nicholas.w.swift/easy-a-star-pathfinding-7e6689c7f7b2][this article]] as a guide. I
won't be going very in-depth of how the algorithm works at a high level, so
please refer to the those articles for more information.

First, we're going to use a new library to make use of a priority queue. Update the
dependencies in your ASDF file to match the following:
#+BEGIN_SRC lisp
:depends-on (#:cl-blt #:queues.priority-queue)
#+END_SRC

If you have you're REPl open, go ahead and load the system with Quicklisp:
#+BEGIN_SRC lisp
(ql:quickload :queues.priority-queue)
#+END_SRC

Create a new file "pathfinding.lisp". We'll start by creating a "node" class to
hold the position of the tile, the "parent" (node that we came from to get to
this node), and the g/h/f variables used in the A* algorithm.

- "h" is the estimated distance from the current node to the target location. We
  just calculate the distance between the positions using the Pythagorean
  Theorem, but other estimations could be used instead.
- "g" is the distance from the starting node to the current node. To calculate
  this, we've decided moving left/right/up/down counts as a distance of 10, and
  moving diagonally counts as 14. The "g" for a given node is the sum of all the
  "g" values of the previous nodes it took to get to the current node.
- "f" is the total cost of the node. It's the sum of the "g" and "h" values.

We'll also include some helper functions for the class as well.
=*all-directions*= stores the directions the path can follow from a given tile,
which is in all eight directions.

#+BEGIN_SRC lisp
(in-package #:cl-rltut)

(defparameter *all-directions*
  (list (cons 0 -1)
        (cons 0 1)
        (cons -1 0)
        (cons 1 0)
        (cons -1 -1)
        (cons -1 1)
        (cons 1 -1)
        (cons 1 1)))

(defclass node ()
  ((g :initform 0 :accessor node/g)
   (h :initform 0 :accessor node/h)
   (f :initform 0 :accessor node/f)
   (distance-from-parent :initarg :distance-from-parent :accessor node/distance-from-parent)
   (parent :initarg :parent :initform nil :accessor node/parent)
   (position :initarg :position :initform nil :accessor node/position)))

(defmethod print-object ((obj node) stream)
  (print-unreadable-object (obj stream :type t)
    (with-slots (position parent) obj
      (format stream "~A, parent ~A" position parent))))

(defun node-equal (n1 n2)
  "The two nodes are equal if their position slots are equal."
  (equal (node/position n1) (node/position n2)))

(defun node-compare (n1 n2)
  "Compares the F slots on the node, and returns true if n1's F slot is less than n2's."
  (< (node/f n1) (node/f n2)))

(defun find-in-queue (queue n)
  "Finds the node N in the QUEUE by it's position. If there are multiple nodes
with the same position, it will return the last one it finds."
  (let ((node nil))
    (queues:map-queue #'(lambda (item)
                          (when (node-equal n item)
                            (setf node item)))
                      queue)
    node))
#+END_SRC

Next, we'll write some helper functions to support the A* algorithm. The
documentation on the functions should describe their functionality.

#+BEGIN_SRC lisp
(defun create-path (current-node)
  "Given a node, return a list of all parent nodes leading to it."
  (do ((path nil)
       (current current-node (node/parent current)))
      ((null current) (reverse path))
    (setf path (append path (list (node/position current))))))

(defun make-node (parent-node node-x node-y direction-from-parent)
  "Creates a NODE instance with the given PARENT, NODE-X and NODE-Y, and calculates the
DISTANCE-FROM-PARENT."
  (let ((distance 10))
    (if (and (not (zerop (car direction-from-parent)))
             (not (zerop (cdr direction-from-parent))))
        (setf distance 14))
    (make-instance 'node :parent parent-node
                         :position (cons node-x node-y)
                         :distance-from-parent distance)))

(defun generate-node-cost (child current-node end-node)
  "Calculates and sets the G, H, and F slots on child."
  (with-slots (g h f position distance-from-parent) child
    (setf g (+ distance-from-parent (node/g current-node))
          h (+ (expt (- (car position) (car (node/position end-node))) 2)
               (expt (- (cdr position) (cdr (node/position end-node))) 2))
          f (+ g h))))

(defun update-open-queue (open-list child-node)
  "Updates an existing entry in OPEN-LIST if one exists that both matches CHILD-NODE, and
has a larger G value. If there is no existing entry matching CHILD-NODE, then if pushes
CHILD-NODE onto OPEN-LIST."
  (let ((existing-child (find-in-queue open-list child-node)))
    (cond ((and existing-child (< (node/g child-node) (node/g existing-child)))
           (queues:queue-change open-list
                                (queues:queue-find open-list existing-child)
                                child-node))
          (t
           (queues:qpush open-list child-node)))))

(defun generate-node-children (current-node map open-list closed-list end-node)
  "Generates a list of all valid nodes that can be moved to from CURRENT-NODE,
and adds them to OPEN-QUEUE. A valid node is one that is within the MAP dimensions,
the tile is not blocking, and the node is not on CLOSED-LIST."
  (dolist (new-position *all-directions*)
    (let ((node-x (+ (car (node/position current-node))
                     (car new-position)))
          (node-y (+ (cdr (node/position current-node))
                     (cdr new-position))))
      (unless (or (> node-x (1- (game-map/w map)))
                  (< node-x 0)
                  (> node-y (1- (game-map/h map)))
                  (< node-y 0))
        (unless (tile/blocked (aref (game-map/tiles map) node-x node-y))
          (let ((child (make-node current-node node-x node-y new-position)))
            ;; child is on the closed list
            (unless (find child closed-list :test 'node-equal)
              (generate-node-cost child current-node end-node)
              (update-open-queue open-list child))))))))
#+END_SRC

Now we can write the main function of the algorithm, =astar=. It will start by
creating node instances for the start and end nodes, as well as the open-list
and closed-list. The open-list is initially populated with the start-node as the
first node to check. It will then begin a =do= loop, which pops the next node
off of the open-list queue to process, and continues looping until the path to
the end-node is found, or the open-list queue is empty. The function will return
a list of positions representing the path from start-node to end-node.

#+BEGIN_SRC lisp
(defun astar (map start end)
  "Returns a list of cons cells as a path from the given start to the given end in the given map."
  (let ((start-node (make-instance 'node :position start))
        (end-node (make-instance 'node :position end))
        (open-list (queues:make-queue :priority-queue :compare #'node-compare))
        (closed-list nil))
    (queues:qpush open-list start-node)
    (do ((current-node (queues:qpop open-list) (queues:qpop open-list)))
        ((null current-node))
      (setf closed-list (append closed-list (list current-node)))

      ;; found the goal
      (when (node-equal current-node end-node)
        (return-from astar (create-path current-node)))

      (generate-node-children current-node map open-list closed-list end-node))))
#+END_SRC

To make use of this function, modify the =move-towards= method in entity.lisp
to call =astar= and move to the second position in the returned path (remember
the first position in the path is where the entity is currently at):
#+BEGIN_SRC lisp
(defmethod move-towards ((e entity) target-x target-y map entities)
  (with-slots (x y) e
    (let ((path (astar map (cons x y) (cons target-x target-y))))
      (when path
        (let ((next-location (nth 1 path)))
          (unless (blocking-entity-at entities (car next-location) (cdr next-location))
            (move e (- (car next-location) x) (- (cdr next-location) y))))))))
#+END_SRC

Now if you run the game, you'll see the enemy monsters following the player
around, and that they can now move diagonally.

*** Combat
Next we'll start to implement the cambat system. First, add a =take-damage=
method to the =fighter= class:
#+BEGIN_SRC lisp
(defgeneric take-damage (component amount))

(defmethod take-damage ((component fighter) amount)
  (decf (fighter/hp component) amount))
#+END_SRC

Also add an =attack= method to the =fighter= class. It calculate the damage of
the attack by subtracting the defenders defense value from the attackers power.
If the damage is above zero, then it'll call the =take-damage= function on the defender.
#+BEGIN_SRC lisp
(defgeneric attack (component target))

(defmethod attack ((component fighter) (target entity))
  (let ((damage (- (fighter/power component) (fighter/defense (entity/fighter target)))))
    (cond
      ((> damage 0)
       (take-damage (entity/fighter target) damage))
       (format t "~A attacks ~A for ~A hit points.~%"
               (entity/name (component/owner component))
               (entity/name target)
               damage)
      (t
       (format t "~A attacks ~A but does no damage.~%"
               (entity/name (component/owner component))
               (entity/name target))))))
#+END_SRC

We can now replace the placeholder messages that we were printing before. In the
cl-rltut.lisp files game loop:
#+BEGIN_SRC lisp -n :hl_lines 5
...
(unless (blocked-p map destination-x destination-y)
  (let ((target (blocking-entity-at entities destination-x destination-y)))
    (cond (target
           (attack (entity/fighter player) target))
          (t
           (move player (car move) (cdr move))
           (fov map (entity/x player) (entity/y player)))))
  (setf (game-state/state game-state) :enemy-turn))
#+END_SRC

And the placeholder in components.lisp =take-turn=:
#+BEGIN_SRC lisp -n :hl_lines 8
(defmethod take-turn ((component basic-monster) target map entities)
  (let* ((monster (component/owner component))
         (in-sight (tile/visible (aref (game-map/tiles map) (entity/x monster) (entity/y monster)))))
    (when in-sight
      (cond ((>= (distance-to monster target) 2)
             (move-towards monster (entity/x target) (entity/y target) map entities))
            ((> (fighter/hp (entity/fighter monster)) 0)
             (attack (entity/fighter monster) target))))))
#+END_SRC

Now if you run the game, you'll be able to attack enemies, and they will attack
you.

*** Messages, Death, and Corpses
Before moving on, we need to come up with a better way to handle the messages
we're printing. In the next tutorial, we'll be displaying these messages to the
player in game, rather than just printing them to the console. Instead of
requiring the =take-damage= and =attack= functions to be in charge of displaying
those messages, it'd be better for them to just return the results of the
actions, and have the message display handled elsewhere. So, we'll modify
=take-damage= and =attack= to return a property list of the results:

#+BEGIN_SRC lisp -n :hl_lines 3-6,9,13-17,20-22
(defmethod take-damage ((component fighter) amount)
  (decf (fighter/hp component) amount)
  (let ((results nil))
    (when (<= (fighter/hp component) 0)
      (setf results (list :dead (component/owner component))))
    results))

(defmethod attack ((component fighter) (target entity))
  (let ((results nil)
        (damage (- (fighter/power component) (fighter/defense (entity/fighter target)))))
    (cond
      ((> damage 0)
       (setf results (append (list :message
                                   (format nil "~A attacks ~A for ~A hit points.~%"
                                           (entity/name (component/owner component))
                                           (entity/name target)
                                           damage))
                             (take-damage (entity/fighter target) damage))))
      (t
       (setf results (list :message (format nil "~A attacks ~A but does no damage.~%"
                                            (entity/name (component/owner component))
                                            (entity/name target))))))))
#+END_SRC

Since the =attack= function is called within the =take-turn= method on the
=component= class, we'll want to update that to return the results it receives
from =attack=:
#+BEGIN_SRC lisp -n :hl_lines 2,9-10
(defmethod take-turn ((component basic-monster) target map entities)
  (let* ((results nil)
         (monster (component/owner component))
         (in-sight (tile/visible (aref (game-map/tiles map) (entity/x monster) (entity/y monster)))))
    (when in-sight
      (cond ((>= (distance-to monster target) 2)
             (move-towards monster (entity/x target) (entity/y target) map entities))
            ((> (fighter/hp (entity/fighter monster)) 0)
             (setf results (attack (entity/fighter monster) target)))))
    results))
#+END_SRC

Now we need to update the game loop to use the results:
#+BEGIN_SRC lisp -n :hl_lines 4,14,22-28,32-39
(defun game-tick (player entities map game-state)
  (declare (type game-state game-state))
  (render-all entities player map *screen-width* *screen-height*)
  (let* ((player-turn-results nil)
         (action (handle-keys))
         (move (getf action :move))
         (exit (getf action :quit)))
    (when (and move (eql (game-state/state game-state) :player-turn))
      (let ((destination-x (+ (entity/x player) (car move)))
            (destination-y (+ (entity/y player) (cdr move))))
        (unless (blocked-p map destination-x destination-y)
          (let ((target (blocking-entity-at entities destination-x destination-y)))
            (cond (target
                   (setf player-turn-results (attack (entity/fighter player) target)))
                  (t
                   (move player (car move) (cdr move))
                   (fov map (entity/x player) (entity/y player)))))
          (setf (game-state/state game-state) :enemy-turn))))
    (when exit
      (setf (game-state/running game-state) nil))

    (let ((message (getf player-turn-results :message))
          (dead-entity (getf player-turn-results :dead)))
      (when message
        (format t message))
      (when dead-entity
        ;; we'll get to this next
        ))

    (when (eql (game-state/state game-state) :enemy-turn)
      (dolist (entity (remove-if-not #'entity/ai entities))
        (let* ((enemy-turn-results (take-turn (entity/ai entity) player map entities))
               (message (getf enemy-turn-results :message))
               (dead-entity (getf enemy-turn-results :dead)))
          (when message
            (format t message))
          (when dead-entity
            ;; we'll get to this next
            )))
      (setf (game-state/state game-state) :player-turn)))

  game-state)
#+END_SRC

With that out of the way, we can work on handling the death of players and
monsters. Create a new file =death-functions.lisp=, with the =kill-player= and
=kill-monster= functions:
#+BEGIN_SRC lisp
(in-package #:cl-rltut)

(defun kill-player (player)
  (setf (entity/char player) #\%
        (entity/color player) (blt:red))

  (values "You died!" :player-dead))

(defun kill-monster (monster)
  (with-slots (char color blocks ai name) monster
    (let ((message (format nil "~A is dead!~%" name)))
      (setf char #\%
            color (blt:red)
            blocks nil
            ai nil
            name (format nil "remains of ~A" name))
      message)))
#+END_SRC

Now update the placeholders in cl-rltut.lisp to call these functions. When the
player is killed, we set the game state to :player-dead and break out of
=game-tick==. The game will continue to run, and the =game-tick= function will
continue to be called, but with that game-state no enemy turns or player turn
will happen. The only option will be to quit the game.
#+BEGIN_SRC lisp -n :hl_lines 6-11,21-29
(let ((message (getf player-turn-results :message))
      (dead-entity (getf player-turn-results :dead)))
  (when message
    (format t message))
  (when dead-entity
    (cond ((equal dead-entity player)
           (setf (values message (game-state/state game-state))
                 (kill-player dead-entity)))
          (t
           (setf message (kill-monster dead-entity))))
    ((format t "~&  ~%") t message)))

(when (eql (game-state/state game-state) :enemy-turn)
  (dolist (entity (remove-if-not #'entity/ai entities))
    (let* ((enemy-turn-results (take-turn (entity/ai entity) player map entities))
           (message (getf enemy-turn-results :message))
           (dead-entity (getf enemy-turn-results :dead)))
      (when message
        (format t message))
      (when dead-entity
        (cond ((equal dead-entity player)
               (setf (values message (game-state/state game-state))
                     (kill-player dead-entity)))
              (t
               (setf message (kill-monster dead-entity))))
        ((format t "~&  ~%") t message)

        (when (eql (game-state/state game-state) :player-dead)
          (return-from game-tick game-state)))))
  (setf (game-state/state game-state) :player-turn))
#+END_SRC

Now if you run the game, you can kill enemies and they will turn into corpses.
If you die, you will no longer be able to move and must exit the game.
[[/cl-rltut/enemy-corpses.png]]

*** Displaying Player Health
One problem with the combat system is the player has no way of knowing how much
health they have remaining. So we'll display the player's health in the game.
Update the render-all function to accept the player as a parameter, and display
their health:
#+BEGIN_SRC lisp -n :hl_lines 1,22-24
(defun render-all (entities player map screen-width screen-height)
  (declare (ignore screen-width))
  (blt:clear)
  (dotimes (y *map-height*)
    (dotimes (x *map-width*)
      (let* ((tile (aref (game-map/tiles map) x y))
             (wall (tile/block-sight tile))
             (visible (tile/visible tile))
             (explored (tile/explored tile)))
        (cond (visible
               (if wall
                   (setf (blt:background-color) (getf *color-map* :light-wall))
                   (setf (blt:background-color) (getf *color-map* :light-ground)))
               (setf (blt:cell-char x y) #\Space))
              (explored
               (if wall
                   (setf (blt:background-color) (getf *color-map* :dark-wall))
                   (setf (blt:background-color) (getf *color-map* :dark-ground)))
               (setf (blt:cell-char x y) #\Space))))))
  (setf (blt:background-color) (blt:black)
        (blt:color) (blt:white))
  (blt:print 1 (1- screen-height) (format nil "HP: ~2d/~2d"
                                          (fighter/hp (entity/fighter player))
                                          (fighter/max-hp (entity/fighter player))))

  (blt:refresh))
#+END_SRC

If you run the game now, you should see the players health and maximum health
displayed in the lower left corner of the screen:
[[/cl-rltut/player-health-display.png]]

*** Rendering Order
One issue we have now is when you walk over a corpse, the corpse is rendered on
top of the player. The last thing we'll do in this post is fix that. Let's start
by creating a new file called =rendering.lisp= and moving the =render-all=
function there. Then, define a variable to hold a property list with the order
to render entities (we'll only use =:corpse= and =:actor= now until we add items):
#+BEGIN_SRC lisp
(defparameter *render-order*
  '(:corpse 1
    :item 2
    :actor 3))
#+END_SRC

Then, we'll need to store the render-order on the =entity= class. We'll default
it to corpse if it's not supplied when creating an =entity= instance:
#+BEGIN_SRC lisp -n :hl_lines 8
(defclass entity ()
  ((name :initarg :name :accessor entity/name)
   (x :initarg :x :accessor entity/x)
   (y :initarg :y :accessor entity/y)
   (char :initarg :char :accessor entity/char)
   (color :initarg :color :accessor entity/color)
   (blocks :initarg :blocks :accessor entity/blocks)
   (render-order :initarg :render-order :accessor entity/render-order :initform :corpse)
   (fighter :initarg :fighter :accessor entity/fighter :initform nil)
   (ai :initarg :ai :accessor entity/ai :initform nil)))
#+END_SRC

Now, update all the places that an =entity= is initialized, to pass in the
render order. In =cl-rltut.lisp= =main= function, for the player:
#+BEGIN_SRC lisp -n :hl_lines 8
(player (make-instance 'entity
                       :name "Player"
                       :x (/ *screen-width* 2)
                       :y (/ *screen-height* 2)
                       :char #\@
                       :color (blt:white)
                       :blocks t
                       :render-order :actor
                       :fighter fighter-component))
#+END_SRC

And in the =place-entities= function in =game-map.lisp=, for each monster:
#+BEGIN_SRC lisp -n :hl_lines 5,12
(cond ((< (random 100) 80)
       (let* ((fighter-component (make-instance 'fighter :hp 10 :defense 0 :power 3))
              (ai-component (make-instance 'basic-monster))
              (orc (make-instance 'entity :name "Orc" :x x :y y :color (blt:green) :char #\o :blocks t
                                          :render-order :actor
                                          :fighter fighter-component :ai ai-component)))
         (nconc entities (list orc))))
      (t
       (let* ((fighter-component (make-instance 'fighter :hp 16 :defense 1 :power 4))
              (ai-component (make-instance 'basic-monster))
              (troll (make-instance 'entity :name "Troll" :x x :y y :color (blt:yellow) :char #\T :blocks t
                                            :render-order :actor
                                            :fighter fighter-component :ai ai-component)))
         (nconc entities (list troll)))))
#+END_SRC

We'll also need to change an entities render order to =:corpse= when they die.
In the =kill-monster= function in =death-functions.lisp=:
#+BEGIN_SRC lisp -n :hl_lines 2,9
(defun kill-monster (monster)
  (with-slots (char color blocks ai name render-order) monster
    (let ((message (format nil "~A is dead!~%" name)))
      (setf char #\%
            color (blt:red)
            blocks nil
            ai nil
            name (format nil "remains of ~A" name)
            render-order :corpse)
      message)))
#+END_SRC

Finally, we need to sort the entities by their render order before rendering
them. In =rendering.lisp= update the =render-all= function to sort the entities:
#+BEGIN_SRC lisp -n :hl_lines 1-3,24-25
(defun render-order-compare (entity-1 entity-2)
  (< (getf *render-order* (entity/render-order entity-1))
     (getf *render-order* (entity/render-order entity-2))))

(defun render-all (entities player map screen-width screen-height)
  (declare (ignore screen-width))
  (blt:clear)
  (dotimes (y *map-height*)
    (dotimes (x *map-width*)
      (let* ((tile (aref (game-map/tiles map) x y))
             (wall (tile/block-sight tile))
             (visible (tile/visible tile))
             (explored (tile/explored tile)))
        (cond (visible
               (if wall
                   (setf (blt:background-color) (getf *color-map* :light-wall))
                   (setf (blt:background-color) (getf *color-map* :light-ground)))
               (setf (blt:cell-char x y) #\Space))
              (explored
               (if wall
                   (setf (blt:background-color) (getf *color-map* :dark-wall))
                   (setf (blt:background-color) (getf *color-map* :dark-ground)))
               (setf (blt:cell-char x y) #\Space))))))
  (mapc #'(lambda (entity) (draw entity (game-map/tiles map)))
        (sort entities #'render-order-compare))
  (setf (blt:background-color) (blt:black)
        (blt:color) (blt:white))
  (blt:print 1 (1- screen-height) (format nil "HP: ~2d/~2d"
                                          (fighter/hp (entity/fighter player))
                                          (fighter/max-hp (entity/fighter player))))

  (blt:refresh))
#+END_SRC

Now when you run the game and walk over a corpse, the player will be rendered on top.
*** Conclusion
That was a long post, but there is now a working combat system. In the next post
we'll be focusing on creating the user interface so that we can display messages
within the game, rather than printing them to the REPL.

You can find the current state of the code on [[https://github.com/nwforrer/cl-rltut/tree/part-6][Github]]. The list of changes since
the previous tutorial can be found at
[[https://github.com/nwforrer/cl-rltut/compare/part-5...part-6]].

If you run into any issues, or have questions/feedback, please open an issue on this
blogs [[https://github.com/nwforrer/blog/issues][GitHub repository]].

Continue to [[/posts/roguelike-tutorial-part7][part 7]].
** DONE Roguelike tutorial for Common Lisp - Part 7 - Creating the interface :roguelike:gamedev:lisp:tutorial:
CLOSED: [2020-02-03 Mon 22:00]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part7
:END:
This tutorial series is based on the [[http://rogueliketutorials.com][Python Roguelike Tutorial]]. This will be
covering [[http://rogueliketutorials.com/tutorials/tcod/part-7/][Part 7]] of that tutorial.

In this part, we will be working on the UI for the game. This will include
a nicer looking health bar, displaying the game messages on screen rather than
in the REPL, and showing entity information when hovering over a tile with your
mouse cursor.

*** The health bar
First, lets work on showing a prettier health bar. Right now we are just
displaying text for the current health of the player. Instead, we will render a
"progress bar" that will fill and deplete based on the player's health. Before
we get into creating this bar, I'd first like to create the concept of a
"panel". This will be a subsection of the screen where various UI elements can
be grouped together, and rendered with a border to show the separation from the
game map itself.

First, update the map height to give some more space for the UI to be displayed:
#+BEGIN_SRC lisp
(defparameter *map-height* 43)
#+END_SRC

Next, create a new file "ui.lisp" to hold the panel implementation, along with
the additional UI elements we'll be creating. Define the "panel" class, which
will hold it's position on screen, it's width and height, along with a list of
the components that should be rendered within. This will include the health bar
once we create it, as well as the message log.
#+BEGIN_SRC lisp
(in-package :cl-rltut.ui)

(defclass panel ()
  ((x :initarg :x :accessor panel/x)
   (y :initarg :y :accessor panel/y)
   (width :initarg :width :accessor panel/width)
   (height :initarg :height :accessor panel/height)
   (components :initarg :components :accessor panel/components :initform nil)))

(defmethod print-object ((object panel) stream)
  (print-unreadable-object (object stream :type t)
    (with-slots (x y width height) object
      (format stream "(~A,~A) ~Ax~A" x y width height))))

(defun make-panel (x y width height)
  (make-instance 'panel
                 :x x :y y :width width :height height))
#+END_SRC

We'll create a base class for UI components that will be rendered within a
panel. It will hold a reference to it's parent panel, and it's position within
the panel:
#+BEGIN_SRC lisp
(defclass panel-component ()
  ((panel :initarg :panel :accessor panel-component/panel)
   (x :initarg :x :accessor panel-component/x)
   (y :initarg :y :accessor panel-component/y)))
#+END_SRC

Now we can create the "bar" class, which we will keep generic enough to be used
for more than just health, such as mana or stamina. The bar will have a "name",
which will be the text rendered within the bar, the width of the bar, the
current value and maximum value, and the colors to use while rendering. It will
also include "value-bind" and "max-bind" slots. These will be functions that can
be called to update the value and maximum values each frame. When a "bar" is
created using the "make-bar" function, it will also add it to it's parent
panel's list of components.
#+BEGIN_SRC lisp
(defclass bar (panel-component)
  ((name :initarg :name :accessor bar/name)
   (total-width :initarg :total-width :accessor bar/total-width)
   (value :initarg :value :accessor bar/value)
   (value-bind :initarg :value-bind)
   (maximum :initarg :maximum :accessor bar/maximum)
   (max-bind :initarg :max-bind)
   (color :initarg :color :accessor bar/color)
   (bg-color :initarg :bg-color :accessor bar/bg-color)))

(defmethod print-object ((object bar) stream)
  (print-unreadable-object (object stream :type t)
    (with-slots (name total-width value maximum) object
      (format stream "~A ~Aw ~A/~A" name total-width value maximum))))

(defun make-bar (name panel x y total-width value color bg-color &key (value-bind nil) (max-bind nil))
  "Create an instance of the `bar` class, and add it to it's parent panels list of components."
  (let ((bar (make-instance 'bar :name name :panel panel
                                 :x x :y y :total-width total-width
                                 :value value :maximum value
                                 :value-bind value-bind :max-bind max-bind
                                 :color color :bg-color bg-color)))
    (setf (panel/components panel) (append (panel/components panel) (list bar)))))
#+END_SRC

Now that we have the classes created, we can work on rendering the UI to the
screen. All of the UI components will implement a "render" method that will
handle rendering it within the panel. For the health bar, we'll render a box for
the background that is the full width of the bar, followed by another bar
over the top of the background whose width is calculated by the percentage of
health the player has. We'll also render the text for the player's health within
the bar.
#+BEGIN_SRC lisp
(defgeneric render (component))

(defmethod render ((bar bar))
  (with-slots (name panel x y total-width value value-bind maximum max-bind color bg-color) bar
    (when value-bind
      (setf value (funcall value-bind)))
    (when max-bind
      (setf maximum (funcall max-bind)))
    (let ((x-pos (+ (panel/x panel) x))
          (y-pos (+ (panel/y panel) y))
          (fill-width (round (* (/ value maximum) total-width)))
          (content (format nil "~A: ~A/~A" name value maximum)))
      (blt:draw-box x-pos y-pos total-width 1 :background-color bg-color :border nil)
      (unless (zerop value)
        (setf fill-width (max 1 fill-width))
        (blt:draw-box x-pos y-pos fill-width 1 :background-color color :border nil))
      (setf (blt:color) (blt:rgba 255 255 255))
      (blt:draw-box x-pos (1- y-pos) total-width 2 :background-color nil :border nil
                                                   :contents content))))
#+END_SRC

The render method for each component will be called by it's parent panel's
"render-panel" method:
#+BEGIN_SRC lisp
(defmethod render-panel ((panel panel))
  (with-slots (x y width height components) panel
      (blt:draw-box x y width height)
      (dolist (component components)
        (render component))))
#+END_SRC

Back in the main function, we will actually create the panel that will hold
these UI components, as well as the health bar. The "value-bind" and "max-bind"
slots on the health bar will be assigned to the methods to retrieve the player's
hp and max-hp slots. The stats instance will then be passed into the "game-tick" method.
#+BEGIN_SRC lisp -n :hl_lines 18-24,28
(defun main ()
  (blt:with-terminal
    (config)
    (let* ((fighter-component (make-instance 'fighter
                                             :hp 30
                                             :defense 2
                                             :power 5))
           (player (make-instance 'entity
                                  :name "Player"
                                  :x (/ *screen-width* 2)
                                  :y (/ *screen-height* 2)
                                  :char #\@
                                  :color (blt:white)
                                  :blocks t
                                  :render-order :actor
                                  :fighter fighter-component))
           (entities (list player))
           (map (make-instance 'game-map :w *map-width* :h *map-height*))
           (stats-panel (make-panel 0 *map-height* *screen-width* (- *screen-height* *map-height*))))
      (make-bar "HP" stats-panel 1 1 15
                (fighter/hp fighter-component)
                (blt:rgba 0 128 0) (blt:rgba 100 100 100)
                :value-bind #'(lambda () (fighter/hp fighter-component))
                :max-bind #'(lambda () (fighter/max-hp fighter-component)))
      (make-map map *max-rooms* *room-min-size* *room-max-size* *map-width* *map-height* player entities *max-enemies-per-room*)
      (fov map (entity/x player) (entity/y player))

      (do ((*state* (make-instance 'game-state :running t :state :player-turn) (game-tick player entities map *state* stats-panel)))
          ((null (game-state/running *state*)))))))
#+END_SRC

The "game-tick" function needs to be updated to include the stats panel as a
parameter, and pass it into the "render-all" function:
#+BEGIN_SRC lisp -n :hl_lines 1,3
(defun game-tick (player entities map game-state stats-panel)
  (declare (type game-state game-state))
  (render-all entities player map stats-panel *screen-width* *screen-height*)
#+END_SRC

Finally, the "render-all" function will take the panel in as a parameter, and
then call the "render-panel" method to render the panel and all it's
components. The previous code to render the health can be removed:
#+BEGIN_SRC lisp -n :hl_lines 1,2,24
(defun render-all (entities player map stats-panel screen-width screen-height)
  (declare (ignore screen-width screen-height player))
  (blt:clear)
  (dotimes (y *map-height*)
    (dotimes (x *map-width*)
      (let* ((tile (aref (game-map/tiles map) x y))
             (wall (tile/block-sight tile))
             (visible (tile/visible tile))
             (explored (tile/explored tile)))
        (cond (visible
               (if wall
                   (setf (blt:background-color) (getf *color-map* :light-wall))
                   (setf (blt:background-color) (getf *color-map* :light-ground)))
               (setf (blt:cell-char x y) #\Space))
              (explored
               (if wall
                   (setf (blt:background-color) (getf *color-map* :dark-wall))
                   (setf (blt:background-color) (getf *color-map* :dark-ground)))
               (setf (blt:cell-char x y) #\Space))))))
  (mapc #'(lambda (entity) (draw entity (game-map/tiles map)))
        (sort entities #'render-order-compare))
  (setf (blt:background-color) (blt:black)
        (blt:color) (blt:white))
  (render-panel stats-panel)

  (blt:refresh))
#+END_SRC

Now, if you run the game, you should see a health bar rendered towards the
bottom of the screen, and it should update when the player gets damaged:
[[/cl-rltut/health-bar.png]]

*** The message log
Now we'll work on displaying the message log on the screen, rather than just in
the REPL. We'll begin by defining the "message-log" class which will hold a list
of messages along with it's width and height. The "message" class will hold the
message text, as well as the message color, so that different messages can be
displayed with different colors.
#+BEGIN_SRC lisp
(defclass message-log (panel-component)
  ((messages :initarg :messages :accessor message-log/messages :initform nil)
   (width :initarg :width :accessor message-log/width)
   (height :initarg :height :accessor message-log/height)))

(defclass message ()
  ((text :initarg :text :accessor message/text)
   (color :initarg :color :accessor message/color)))

(defun make-message-log (panel x y width height)
  (let ((log (make-instance 'message-log :panel panel :x x :y y :width width :height height)))
    (setf (panel/components panel) (append (panel/components panel) (list log)))
    log))
#+END_SRC

We will also want a method to add a message to the message log. This will add a
message to the message-log "messages" list, and will also take care of removing
old messages when the messages will overflow the height of the message log.
We'll also handle "word-wrapping" when messages are adding that exceed the width
of the message log.
#+BEGIN_SRC lisp
(defun word-wrap (full-line width)
  (do ((lines nil)
       (line full-line))
      ((zerop (length line)) lines)
    (cond ((< (length line) width)
           (setf lines (append lines (list line))
                 line nil))
           (t
            (setf lines (append lines (list (subseq line 0 width)))
                  line (subseq line width))))))

(defgeneric add-message (log message &key color))
(defmethod add-message ((log message-log) message &key (color (blt:rgba 255 255 255)))
  (with-slots (messages width height) log
    (let ((wrapped-text (word-wrap message width)))
      (dolist (text wrapped-text)
        (setf messages (append messages (list (make-instance 'message :text text :color color))))
        (when (>= (length messages) (1- height))
          (setf messages (rest messages)))))))
#+END_SRC

Now, to implement the "render" method for the message log, we'll just loop over
all of the messages, and render them line-by-line:
#+BEGIN_SRC lisp
(defmethod render ((log message-log))
  (let ((x (+ (panel-component/x log) (panel/x (panel-component/panel log))))
        (y (+ (panel-component/y log) (panel/y (panel-component/panel log)))))
    (dolist (message (message-log/messages log))
      (setf (blt:color) (message/color message))
      (blt:print x y (message/text message))
      (incf y))))
#+END_SRC

Now, back in the main function, we can create the message log, and add an
initial message.
#+BEGIN_SRC lisp -n :hl_lines 20,29
(defun main ()
  (blt:with-terminal
    (config)
    (let* ((fighter-component (make-instance 'fighter
                                             :hp 30
                                             :defense 2
                                             :power 5))
           (player (make-instance 'entity
                                  :name "Player"
                                  :x (/ *screen-width* 2)
                                  :y (/ *screen-height* 2)
                                  :char #\@
                                  :color (blt:white)
                                  :blocks t
                                  :render-order :actor
                                  :fighter fighter-component))
           (entities (list player))
           (map (make-instance 'game-map :w *map-width* :h *map-height*))
           (stats-panel (make-panel 0 *map-height* *screen-width* (- *screen-height* *map-height*)))
           (message-log (make-message-log stats-panel 20 2 (- *screen-width* 20) (- *screen-height* *map-height* 1))))
      (make-bar "HP" stats-panel 1 2 15
                (fighter/hp fighter-component)
                (blt:rgba 0 128 0) (blt:rgba 100 100 100)
                :value-bind #'(lambda () (fighter/hp fighter-component))
                :max-bind #'(lambda () (fighter/max-hp fighter-component)))
      (make-map map *max-rooms* *room-min-size* *room-max-size* *map-width* *map-height* player entities *max-enemies-per-room*)
      (fov map (entity/x player) (entity/y player))

      (add-message message-log "Welcome to the dungeon!")

      (do ((*state* (make-instance 'game-state :running t :state :player-turn) (game-tick player entities map *state* stats-panel)))
          ((null (game-state/running *state*)))))))
#+END_SRC

If you run the game now, you should see that initial message displayed on
screen:
[[/cl-rltut/initial-message-log.png]]

To have the remaining messages displayed in the log, replace the "format"
function calls with "add-message" calls in the game-tick function. Once done,
you will see the message log fill up with messages:
[[/cl-rltut/message-log.png]]

*** Entities under cursor
The final change we'll make is to incorporate mouse movement into the UI. When
the mouse cursor is over a tile, we'll display the list of all entity names to
the player. This will make it easier for player's to learn which entities are
which once there are more than two in the game.

The first change is to configure BearLibTerminal to track mouse movement events:
#+BEGIN_SRC lisp -n :hl_lines 5
(defun config ()
  (blt:set "window.resizeable = true")
  (blt:set "window.size = ~Ax~A" *screen-width* *screen-height*)
  (blt:set "output.vsync = true")
  (blt:set "input.filter = keyboard, mouse")
  (blt:set "window.title = Roguelike"))
#+END_SRC

Now, in "rendering.lisp" we'll need a function to retrieve a list of all entity
names under the mouse cursor. This will first check to make sure the tile is
visible by the player. Then, it'll loop over the list of entities, and for any
entities at the mouse cursor position, it will append the entity name to the
"names" list. Then, to join all of the names to a string separated by a comma,
we'll use the "format" method, with the "{}" descriptor to iterate over the
names, and the "^" descriptor to only include the comma when it's not the last
name in the list.
#+BEGIN_SRC lisp
(defun get-names-under-mouse (x y entities map)
  (when (and (< y (game-map/h map))
             (< x (game-map/w map)))
    (let ((names nil)
          (in-fov (tile/visible (aref (game-map/tiles map) x y))))
      (when in-fov
        (dolist (entity entities)
          (when (and (= (entity/x entity) x)
                     (= (entity/y entity) y))
            (setf names (append names (list (entity/name entity)))))))
      (format nil "~{~A~^, ~}" names))))
#+END_SRC

Finally, update the "render-all" function to call this method, and render the
names to the screen.
#+BEGIN_SRC lisp
(let ((entity-names (get-names-under-mouse (blt:mouse-x) (blt:mouse-y) entities map)))
(when entity-names
    (setf (blt:color) (blt:yellow))
    (blt:print (1+ (panel/x stats-panel)) (1+ (panel/y stats-panel)) entity-names)))
#+END_SRC

Now when you run the game and hover your mouse over an entity, it will display
their names to the screen:
[[/cl-rltut/entities-under-cursor.png]]

*** Conclusion
These were some changes to improve the user experience by making the UI nicer to
look at, and more informative.

You can find the current state of the code on [[https://github.com/nwforrer/cl-rltut/tree/part-6][Github]]. The list of changes since
the previous tutorial can be found at
[[https://github.com/nwforrer/cl-rltut/compare/part-6...part-7-1]].

If you run into any issues, or have questions/feedback, please open an issue on this
blogs [[https://github.com/nwforrer/blog/issues][GitHub repository]].

Continue to [[/posts/roguelike-tutorial-part8][part 8]].
** TODO Roguelike tutorial for Common Lisp - Part 8 - Items and inventory :roguelike:gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part8
:END:
This tutorial series is based on the [[http://rogueliketutorials.com][Python Roguelike Tutorial]]. This will be
covering [[http://rogueliketutorials.com/tutorials/tcod/part-8/][Part 8]] of that tutorial.

In this part, we will add items to the game, as well as an inventory system to
interact with the items. For now, we will only be adding one item, a healing
potion, but we will be adding more items in the future.

*** Placing items
To start, we will update the map generation code to start placing healing
potions. Create a new function "place-items" that will place items in random
positions within a room. Then, update the "place-entities" method to take in a new parameter for the
max items allowed per room, and to call the new "place-items" function with a
random number of items to place. We'll also separate out a new function for
"place-monsters" so that the "place-entities" function doesn't get too large.

#+BEGIN_SRC lisp
(defun place-monsters (room entities num-monsters)
  (dotimes (monster-index num-monsters)
    (let ((x (+ (random (round (/ (- (rect/x2 room) (rect/x1 room) 1) 2))) (1+ (rect/x1 room))))
          (y (+ (random (round (/ (- (rect/y2 room) (rect/y1 room) 1) 2))) (1+ (rect/y1 room)))))
      (unless (entity-at entities x y)
        (cond ((< (random 100) 80)
               (let* ((fighter-component (make-instance 'fighter :hp 10 :defense 0 :power 3))
                      (ai-component (make-instance 'basic-monster))
                      (orc (make-instance 'entity :name "Orc" :x x :y y :color (blt:green) :char #\o :blocks t
                                                  :render-order :actor
                                                  :fighter fighter-component :ai ai-component)))
                 (nconc entities (list orc))))
              (t
               (let* ((fighter-component (make-instance 'fighter :hp 16 :defense 1 :power 4))
                      (ai-component (make-instance 'basic-monster))
                      (troll (make-instance 'entity :name "Troll" :x x :y y :color (blt:yellow) :char #\T :blocks t
                                                    :render-order :actor
                                                    :fighter fighter-component :ai ai-component)))
                 (nconc entities (list troll)))))))))

(defun place-items (room entities num-items)
  (dotimes (item-index num-items)
    (let ((x (+ (random (round (/ (- (rect/x2 room) (rect/x1 room) 1) 2))) (1+ (rect/x1 room))))
          (y (+ (random (round (/ (- (rect/y2 room) (rect/y1 room) 1) 2))) (1+ (rect/y1 room)))))
      (unless (entity-at entities x y)
        (let ((potion (make-instance 'entity :name "Healing Potion" :x x :y y :color (blt:purple)
                                           :char #\! :blocks nil :render-order :item)))
          (nconc entities (list potion)))))))

(defgeneric place-entities (map room entities max-enemies-per-room max-items-per-room))

(defmethod place-entities ((map game-map) (room rect) entities max-enemies-per-room max-items-per-room)
  (let ((num-monsters (random max-enemies-per-room))
        (num-items (random (1+ max-items-per-room))))
    (place-monsters room entities num-monsters)
    (place-items room entities num-items)))
#+END_SRC

Now, in the "make-map" method, add a new "max-items-per-room" parameter, and
pass it through to the "place-entities" method.
#+BEGIN_SRC lisp
(defgeneric make-map (map max-rooms room-min-size room-max-size map-width map-height player entities max-enemies-per-room max-items-per-room))
(defmethod make-map ((map game-map) max-rooms room-min-size room-max-size map-width map-height player entities max-enemies-per-room max-items-per-room)
    ...
    (place-entities map new-room entities max-enemies-per-room max-items-per-room)
    ...)
#+END_SRC

In the main "cl-rltut.lisp" file, add the max items variable, and update the
call to "make-map" to pass the variable through.
#+BEGIN_SRC lisp
(defparameter *max-items-per-room* 2)

(make-map map *max-rooms* *room-min-size* *room-max-size* *map-width* *map-height* player entities *max-enemies-per-room* *max-items-per-room*)
#+END_SRC

Now, if you run the game, you should see some health potions placed throughout
the map. However, you won't be able to interact with them, which is what we'll
be working on now.
*** Picking up items
Now, we will create a way to pickup the items we've placed on the map. The first
step will be to create an inventory to hold all of the items we pick up. In the
"components.lisp" file, create a new "inventory" class:
#+BEGIN_SRC lisp
(defclass inventory (component)
  ((capacity :initarg :capacity :accessor inventory/capacity)
   (items :initarg :items :accessor inventory/items :initform nil)))
#+END_SRC

Next, we need a way to tell which entities can be picked up and placed in the
inventory. For that, create an "item" component, which will be added to any
entities that can be pickup up. For now, it won't hold any additional slots, but
some will be added later.
#+BEGIN_SRC lisp
(defclass item (component))
#+END_SRC

Now, we need to add slots for these two new components to the entity class:
#+BEGIN_SRC lisp -n :hl_lines 11,12
(defclass entity ()
  ((name :initarg :name :accessor entity/name)
   (x :initarg :x :accessor entity/x)
   (y :initarg :y :accessor entity/y)
   (char :initarg :char :accessor entity/char)
   (color :initarg :color :accessor entity/color)
   (blocks :initarg :blocks :accessor entity/blocks)
   (render-order :initarg :render-order :accessor entity/render-order :initform :corpse)
   (fighter :initarg :fighter :accessor entity/fighter :initform nil)
   (ai :initarg :ai :accessor entity/ai :initform nil)
   (item :initarg :item :accessor entity/item :initform nil)
   (inventory :initarg :inventory :accessor entity/inventory :initform nil)))
#+END_SRC

Now, make sure to add an inventory component to the player, and an item
component to the healing potions.
#+BEGIN_SRC lisp -n :hl_lines 3-4,13,23,25
(defun main (...)
...
(inventory-component (make-instance 'inventory
                                               :capacity 26))
(player (make-instance 'entity
                                  :name "Player"
                                  :x (/ *screen-width* 2)
                                  :y (/ *screen-height* 2)
                                  :char #\@
                                  :color (blt:white)
                                  :blocks t
                                  :render-order :actor
                                  :fighter fighter-component
                                  :inventory inventory-component))
...)

(defun place-items (room entities num-items)
  (dotimes (item-index num-items)
    (let* ((x (+ (random (round (/ (- (rect/x2 room) (rect/x1 room) 1) 2))) (1+ (rect/x1 room))))
           (y (+ (random (round (/ (- (rect/y2 room) (rect/y1 room) 1) 2))) (1+ (rect/y1 room))))
           (existing-entity (entity-at entities x y)))
      (unless existing-entity
        (let* ((item-component (make-instance 'item))
               (potion (make-instance 'entity :name "Healing Potion" :x x :y y :color (blt:purple)
                                              :item item-component
                                              :char #\! :blocks nil :render-order :item)))
          (nconc entities (list potion)))))))
#+END_SRC

The way we're going to have the player pickup an item is to stand on top of it
and press the 'g' key. We'll start by accepting the players input. Update the
handle-keys function to check for the 'g' key being pressed, and to return a
result that the player wants to pickup an item:
#+BEGIN_SRC lisp -n :hl_lines 12
(defun handle-keys ()
  (when (blt:has-input-p)
    (blt:key-case (blt:read)
                  ((or :up :k) (list :move (cons 0 -1)))
                  ((or :down :j) (list :move (cons 0 1)))
                  ((or :left :h) (list :move (cons -1 0)))
                  ((or :right :l) (list :move (cons 1 0)))
                  (:y (list :move (cons -1 -1)))
                  (:u (list :move (cons 1 -1)))
                  (:b (list :move (cons -1 1)))
                  (:n (list :move (cons 1 1)))
                  (:g (list :pickup t))
                  (:escape (list :quit t))
                  (:close (list :quit t)))))
#+END_SRC

The inventory class will need a method to add new items to it's item list:
#+BEGIN_SRC lisp
(defgeneric add-item (inventory item))
(defmethod add-item ((inventory inventory) (item entity))
  (let ((results nil))
    (with-slots (items capacity) inventory
      (cond
        ((>= (length items) capacity)
         (setf results (list :item-added nil
                             :message "You cannot carry any more, your inventory is full")))
        (t
         (setf results (list :item-added item
                             :message (format nil "You pick up the ~A" (entity/name item))
                             :message-color (blt:yellow)))
         (setf items (append items (list item))))))
    results))
#+END_SRC

Next, we'll need a way to process the results of adding an item to the
inventory. But before we do, the game-tick function is getting a little large,
so lets pull out the turn handling code into separate functions for the
player-turn, handle-player-results, and enemy-turn:
#+BEGIN_SRC lisp
(defun player-turn (game-state map player action)
  (let ((player-turn-results nil)
        (move (getf action :move)))
    (when move
      (let ((destination-x (+ (entity/x player) (car move)))
            (destination-y (+ (entity/y player) (cdr move))))
        (unless (blocked-p map destination-x destination-y)
          (let ((target (blocking-entity-at (game-state/entities game-state) destination-x destination-y)))
            (cond (target
                   (setf player-turn-results (attack (entity/fighter player) target)))
                  (t
                   (move player (car move) (cdr move))
                   (fov map (entity/x player) (entity/y player)))))
          (setf (game-state/state game-state) :enemy-turn))))

    (values player-turn-results game-state)))

(defun handle-player-results (game-state player player-turn-results log)
  (let ((message (getf player-turn-results :message))
        (message-color (if (getf player-turn-results :message-color)
                           (getf player-turn-results :message-color)
                           (blt:white)))
        (dead-entity (getf player-turn-results :dead))
        (item-added (getf player-turn-results :item-added)))
    (when message
      (add-message log message :color message-color))
    (when dead-entity
      (cond ((equal dead-entity player)
             (setf (values message (game-state/state game-state))
                   (kill-player dead-entity)))
            (t
             (setf message (kill-monster dead-entity))))
      (add-message log message :color (blt:orange))))
  game-state)

(defun enemy-turn (game-state player map log)
  (dolist (entity (remove-if-not #'entity/ai (game-state/entities game-state)))
    (let* ((enemy-turn-results (take-turn (entity/ai entity) player map (game-state/entities game-state)))
           (message (getf enemy-turn-results :message))
           (dead-entity (getf enemy-turn-results :dead)))
      (when message
        (add-message log message))
      (when dead-entity
        (cond ((equal dead-entity player)
               (setf (values message (game-state/state game-state))
                     (kill-player dead-entity)))
              (t
               (setf message (kill-monster dead-entity))))
        (add-message log message :color (blt:red)))))
  game-state)

(defun game-tick (player map game-state stats-panel log)
  (declare (type game-state game-state))
  (declare (type message-log log))
  (render-all game-state player map stats-panel *screen-width* *screen-height*)
  (let* ((player-turn-results nil)
         (action (handle-keys game-state))
         (exit (getf action :quit)))

    (when (eql (game-state/state game-state) :player-turn)
      (setf (values player-turn-results game-state) (player-turn game-state map player action)))

    (when exit
      (if (or (eql (game-state/state game-state) :show-inventory)
              (eql (game-state/state game-state) :drop-inventory))
          (setf (game-state/state game-state) (game-state/previous-state game-state))
          (setf (game-state/running game-state) nil)))

    (setf game-state (handle-player-results game-state player player-turn-results log))

    (when (eql (game-state/state game-state) :enemy-turn)
      (setf game-state (enemy-turn game-state player map log))
      (when (eql (game-state/state game-state) :player-dead)
        (return-from game-tick game-state))
      (setf (game-state/state game-state) :player-turn)))

  game-state)
#+END_SRC

Now, we can handle the item pickup action. When the player wants to pickup an
item, we will loop through all of the entities to see which ones are on the same
tile as the player. If one of the entities is on the same tile, and it is an
item, then the player will pick it up.
#+BEGIN_SRC lisp -n :hl_lines 4,17-22
(defun player-turn (game-state map player action)
  (let ((player-turn-results nil)
        (move (getf action :move))
        (pickup (getf action :pickup)))
    (when move
      (let ((destination-x (+ (entity/x player) (car move)))
            (destination-y (+ (entity/y player) (cdr move))))
        (unless (blocked-p map destination-x destination-y)
          (let ((target (blocking-entity-at (game-state/entities game-state) destination-x destination-y)))
            (cond (target
                   (setf player-turn-results (attack (entity/fighter player) target)))
                  (t
                   (move player (car move) (cdr move))
                   (fov map (entity/x player) (entity/y player)))))
          (setf (game-state/state game-state) :enemy-turn))))

    (when pickup
      (dolist (entity (game-state/entities game-state))
        (when (and (entity/item entity)
                   (= (entity/x entity) (entity/x player))
                   (= (entity/y entity) (entity/y player)))
          (setf player-turn-results (add-item (entity/inventory player) entity)))))

    (values player-turn-results game-state)))
#+END_SRC

Then, process the results of pickup up the item. When the item is picked up, it
needs to be removed from the entities list so that it is no longer rendered on
the map. Picking up an item should also use up the player's turn.
#+BEGIN_SRC lisp -n :hl_lines 7,17-22
(defun handle-player-results (game-state player player-turn-results log)
  (let ((message (getf player-turn-results :message))
        (message-color (if (getf player-turn-results :message-color)
                           (getf player-turn-results :message-color)
                           (blt:white)))
        (dead-entity (getf player-turn-results :dead))
        (item-added (getf player-turn-results :item-added)))
    (when message
      (add-message log message :color message-color))
    (when dead-entity
      (cond ((equal dead-entity player)
             (setf (values message (game-state/state game-state))
                   (kill-player dead-entity)))
            (t
             (setf message (kill-monster dead-entity))))
      (add-message log message :color (blt:orange)))
    (when item-added
      (setf (game-state/entities game-state) (remove-if
                                              #'(lambda (entity)
                                                  (eql entity item-added))
                                              (game-state/entities game-state))
            (game-state/state game-state) :enemy-turn)))
  game-state)
#+END_SRC

Now, if you run the game, you should be able to pick up the healing potions by
pressing 'g' while on the same tile. However, you aren't able to do anything
with the yet. Before we can implement using items, we need to be able to display
what the player has in their inventory.
*** Displaying the inventory menu
We're going to add in an inventory menu that the player will be able to
display by pressing 'i'. From the inventory menu, the player will be presented
with all of the items they are holding, and shown a keyboard button they can
press which will correspond with each item.

To start, create a new "menu.lisp" file, with a generic "menu" function that
will handle rendering the menu with a header and a list of options to display.
For each item in the list of options, it will display an alphabetic character
which the player can press to use the items, starting at 'a' and increasing by
one for each subsequent option. Since it will use one alphabetic character as
the keyboard shortcut for every item, it will be limited to displaying a maximum
of 26 options.
#+BEGIN_SRC lisp
(defun menu (header options width screen-width screen-height)
  (assert (<= (length options) 26))

  (let* ((header-height 3)
         (height (+ (length options) header-height 1))
         (box-x (round (- (/ screen-width 2) (/ width 2))))
         (box-y (round (- (/ screen-height 2) (/ height 2)))))

    (blt:draw-box box-x box-y width height :contents header)

    (let ((y (+ header-height box-y))
          (letter-index (char-code #\a)))
      (dolist (option-text options)
        (let* ((text (concatenate 'string "(" (string (code-char letter-index)) ") " option-text)))
          (blt:print (1+ box-x) y text)
          (incf y)
          (incf letter-index))))))
#+END_SRC

Next, create an inventory-menu function that will pass the inventory items
through to the more generic "menu" function:
#+BEGIN_SRC lisp
(defun inventory-menu (header inventory inventory-width screen-width screen-height)
  (let ((options (if (zerop (length (inventory/items inventory)))
                     '("Inventory is empty.")
                     (mapcar #'(lambda (i)
                                 (entity/name i))
                             (inventory/items inventory)))))
    (menu header options inventory-width screen-width screen-height)))
#+END_SRC

We now need to be able to display the menu. When the player opens the inventory,
we will have the game switch to a new "show-inventory" state. We'll need to also
track the previous state that the game was in so that when the inventory menu is
closed, the game returns to the correct state so that the player doesn't lose a
turn if they just open and close the inventory without using anything. We'll use
the 'i' key to open the inventory.

Update the game-state class to hold the previous state:
#+BEGIN_SRC lisp
(defclass game-state ()
  ((state :initarg :state :accessor game-state/state)
   (previous-state :initarg :previous-state :accessor game-state/previous-state :initform nil)
   (entities :initarg :entities :accessor game-state/entities)
   (running :initarg :running :accessor game-state/running)))

(defmethod initialize-instance :after ((game-state game-state) &rest initargs)
  (declare (ignore initargs))
  (with-slots (state previous-state) game-state
    (unless previous-state
      (setf previous-state state))))
#+END_SRC

Update the handle-keys function to check for the 'i' key:
#+BEGIN_SRC lisp -n :hl_lines 13
(defun handle-keys ()
  (when (blt:has-input-p)
    (blt:key-case (blt:read)
                  ((or :up :k) (list :move (cons 0 -1)))
                  ((or :down :j) (list :move (cons 0 1)))
                  ((or :left :h) (list :move (cons -1 0)))
                  ((or :right :l) (list :move (cons 1 0)))
                  (:y (list :move (cons -1 -1)))
                  (:u (list :move (cons 1 -1)))
                  (:b (list :move (cons -1 1)))
                  (:n (list :move (cons 1 1)))
                  (:g (list :pickup t))
                  (:i (list :show-inventory t))
                  (:escape (list :quit t))
                  (:close (list :quit t)))))
#+END_SRC

Update the player-turn function to check for the show-inventory action, change
the state to show-inventory and store the current state:
#+BEGIN_SRC lisp -n :hl_lines 5, 25-28
(defun player-turn (game-state map player action)
  (let ((player-turn-results nil)
        (move (getf action :move))
        (pickup (getf action :pickup))
        (show-inventory (getf action :show-inventory)))
    (when move
      (let ((destination-x (+ (entity/x player) (car move)))
            (destination-y (+ (entity/y player) (cdr move))))
        (unless (blocked-p map destination-x destination-y)
          (let ((target (blocking-entity-at (game-state/entities game-state) destination-x destination-y)))
            (cond (target
                   (setf player-turn-results (attack (entity/fighter player) target)))
                  (t
                   (move player (car move) (cdr move))
                   (fov map (entity/x player) (entity/y player)))))
          (setf (game-state/state game-state) :enemy-turn))))

    (when pickup
      (dolist (entity (game-state/entities game-state))
        (when (and (entity/item entity)
                   (= (entity/x entity) (entity/x player))
                   (= (entity/y entity) (entity/y player)))
          (setf player-turn-results (add-item (entity/inventory player) entity)))))

    (when show-inventory
      (with-slots (previous-state state) game-state
        (setf previous-state state
              state :show-inventory)))

    (values player-turn-results game-state)))
#+END_SRC

We'll also want to update the game-tick function so that when "escape" is
pressed and the inventory menu is open, the menu closes instead of exiting the game.
#+BEGIN_SRC lisp -n :hl_lines 13-16
(defun game-tick (player map game-state stats-panel log)
  (declare (type game-state game-state))
  (declare (type message-log log))
  (render-all game-state player map stats-panel *screen-width* *screen-height*)
  (let* ((player-turn-results nil)
         (action (handle-keys game-state))
         (inventory-index (getf action :inventory-index))
         (exit (getf action :quit)))

    (when (eql (game-state/state game-state) :player-turn)
      (setf (values player-turn-results game-state) (player-turn game-state map player action)))

    (when exit
      (if (eql (game-state/state game-state) :show-inventory)
          (setf (game-state/state game-state) (game-state/previous-state game-state))
          (setf (game-state/running game-state) nil)))

    (setf game-state (handle-player-results game-state player player-turn-results log))

    (when (eql (game-state/state game-state) :enemy-turn)
      (setf game-state (enemy-turn game-state player map log))
      (when (eql (game-state/state game-state) :player-dead)
        (return-from game-tick game-state))
      (setf (game-state/state game-state) :player-turn)))

  game-state)
#+END_SRC

Now to finally render the inventory menu, update the render-all function to take
in the game-state as a parameter, and to render the menu when the state is
currently set to show-inventory. Make sure to update the call to render-all to
pass in the new game-state parameter:
#+BEGIN_SRC lisp -n :hl_lines 1, 31-33
(defun render-all (game-state player map stats-panel screen-width screen-height)
  (blt:clear)
  (dotimes (y *map-height*)
    (dotimes (x *map-width*)
      (let* ((tile (aref (game-map/tiles map) x y))
             (wall (tile/block-sight tile))
             (visible (tile/visible tile))
             (explored (tile/explored tile)))
        (cond (visible
               (if wall
                   (setf (blt:background-color) (getf *color-map* :light-wall))
                   (setf (blt:background-color) (getf *color-map* :light-ground)))
               (setf (blt:cell-char x y) #\Space))
              (explored
               (if wall
                   (setf (blt:background-color) (getf *color-map* :dark-wall))
                   (setf (blt:background-color) (getf *color-map* :dark-ground)))
               (setf (blt:cell-char x y) #\Space))))))
  (let ((entities (game-state/entities game-state)))
    (mapc #'(lambda (entity) (draw entity (game-map/tiles map)))
          (sort (copy-seq entities) #'render-order-compare))
    (setf (blt:background-color) (blt:black)
          (blt:color) (blt:white))
    (render-panel stats-panel)

    (let ((entity-names (get-names-under-mouse (blt:mouse-x) (blt:mouse-y) entities map)))
      (when entity-names
        (setf (blt:color) (blt:yellow))
        (blt:print (1+ (panel/x stats-panel)) (1+ (panel/y stats-panel)) entity-names))))

  (when (or (eql (game-state/state game-state) :show-inventory))
    (let ((inventory-title "Press key next to item to use it, or Esc to cancel."))
      (inventory-menu inventory-title (entity/inventory player) 50 screen-width screen-height)))

  (blt:refresh))
#+END_SRC

Now, if you run the game, you should be able to open the inventory menu by
pressing 'i'. If you are holding any items, they should be displayed, and you
should be able to press the escape key to close the menu.

[[/cl-rltut/inventory-menu.png]]
*** Using items
*** Dropping items
*** Conclusion
You can find the current state of the code on [[https://github.com/nwforrer/cl-rltut/tree/part-6][Github]]. The list of changes since
the previous tutorial can be found at
[[https://github.com/nwforrer/cl-rltut/compare/part-7-1...part-8]].

If you run into any issues, or have questions/feedback, please open an issue on this
blogs [[https://github.com/nwforrer/blog/issues][GitHub repository]].
** TODO Roguelike tutorial for Common Lisp - Part 9 - Ranged scrolls and targeting :roguelike:gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part9
:END:
** TODO Roguelike tutorial for Common Lisp - Part 10 - Saving and loading :roguelike:gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part10
:END:
** TODO Roguelike tutorial for Common Lisp - Part 11 - Multiple dungeon floors :roguelike:gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part11
:END:
** TODO Roguelike tutorial for Common Lisp - Part 12 - Increasing the difficulty :roguelike:gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part12
:END:
** TODO Roguelike tutorial for Common Lisp - Part 13 - Gearing up :roguelike:gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part13
:END:
