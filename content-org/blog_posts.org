#+HUGO_SECTION: posts
#+HUGO_BASE_DIR: ../
#+author: Nick Forrer

* Hello
** Hello World
:PROPERTIES:
:EXPORT_FILE_NAME: hello-world
:EXPORT_DATE: 2019-06-23
:END:
Testing the site
* Tutorials :@tutorials:
** DONE Roguelike tutorial for Common Lisp - Part 0 - Setup :roguelike:gamedev:lisp:tutorial:
CLOSED: [2019-06-23 Sun 10:24]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part0
:END:
This set of tutorials is going to follow the [[http://rogueliketutorials.com/tutorials/tcod/][Python TCOD tutorial]], but will be
written in Common Lisp and use the BearLibTerminal library.

*** Prior Knowledge
This tutorial assumes you are familiar with programming in Common Lisp. If
you're not familiar, I would highly recommend checking out [[http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/][A Road to Common Lisp]]
on Steve Losh's blog. It provides many valuable resources to get up to speed
with Common Lisp, and is how I got started.
*** Installation
You will need the following installed:
- A Common Lisp implementation. I will be using and testing my code against
  [[http://www.sbcl.org/][SBCL]].
- [[https://www.quicklisp.org/beta/][Quicklisp]]
- An editor. I use Emacs, with the [[https://github.com/hlissner/doom-emacs][Doom Emacs]] configuration.

I run Linux (Fedora) on my machine, and SBCL is available in the default
repositories. If it is not available in your distro (or if you're not running
Linux), check out the [[http://www.sbcl.org/getting.html][getting started]] page.

Quicklisp should be configured based on the installation guide on their [[https://www.quicklisp.org/beta/][home page]].

For the Emacs configuration, the most important peice is to have a REPL
available. I use the [[https://github.com/joaotavora/sly][sly]] package, although [[https://common-lisp.net/project/slime/][SLIME]] is popular as well. Having a
REPL running in your editor makes the development process much more efficient
and enjoyable.

*** Project setup
Once you have everything installed that you need, you can get the your project
skeleton created, with the needed dependencies. Since you have Quicklisp
installed, it will be easy to generate a project skeleton using [[https://www.xach.com/lisp/quickproject/][Quickproject]].

First, open emacs and start your REPL (if you're using sly, the Emacs command is
just M-x "sly"). In the REPL:

#+BEGIN_SRC common-lisp
(ql:quickload :quickproject)
(quickproject:make-project #p"cl-rltut" :depends-on '(:cl-blt))
#+END_SRC

That should create a "cl-rltut" directory within the current working
directory of your REPL (this can be shown for sly with the "sly-pwd" command,
and changed with the "sly-cd" command). Within the project directory, you should
see an ASDF file named "cl-rltut.asd", which looks like the following:
#+BEGIN_SRC common-lisp
(asdf:defsystem #:cl-rltut
  :description "Describe cl-rltut here"
  :author "Nick Forrer"
  :license  "MIT"
  :version "0.0.1"
  :serial t
  :depends-on (#:cl-blt)
  :components ((:file "package")
               (:file "cl-rltut")))
#+END_SRC

You will also need to download the cl-blt package, which contains the
Common Lisp bindings for BearLibTerminal. The reason for this is because
cl-blt is not currently available in an online repository that
Quicklisp could download it automatically. Download the package using:

#+BEGIN_SRC sh
git clone https://github.com/sjl/cl-blt.git ~/quicklisp/local-projects/cl-blt
#+END_SRC

That will clone the cl-blt Git repo into a directory that Quicklisp will look at
when trying to load an ASDF system.

In addition to the Common Lisp bindings, you will also need the BearLibTerminal
library itself. Download the appropriate binary for your system from
http://foo.wyrd.name/en:bearlibterminal#download. Once downloaded, extract the
archive and find the shared library dependency. For the Linux archive, this will
be Linux64/libBearLibTerminal.so (assuming you are using a 64-bit OS). This file
should be placed in a "lib" directory in the root of your project.

To make it easier to load your project from the REPL, you can create a symlink
in the local-projects directly that points to your project, so that Quicklisp
can always find it (use the correct path to your project instead of ~/src/lisp/cl-rltut):

#+BEGIN_SRC sh
ln -s ~/src/lisp/cl-rltut ~/quicklisp/local-projects
#+END_SRC

With all of that in place, you should now be able to load your projects system
in the REPL to ensure in can find all the dependencies with:

#+BEGIN_SRC common-lisp
(ql:quickload :cl-rltut)
#+END_SRC

Assuming you don't see any errors, then your project is all set to continue with
the tutorial! To see what the project should look like at this point, you can
find the current state for Part 0 here: https://github.com/nwforrer/cl-rltut/tree/part-0.

*** Questions and Feedback
If you run into any issues, or have some feedback, feel free to email me at:
nwforrer AT gmail.com.

Continue to the [[/posts/roguelike-tutorial-part1][next tutorial]].

** DONE Roguelike tutorial for Common Lisp - Part 1 - Drawing the player :roguelike:gamedev:lisp:tutorial:
CLOSED: [2019-06-25 Tue 20:10]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part1
:END:
Welcome to the first part of the tutorial! If you haven't already, please check
out [[/posts/roguelike-tutorial-part0][Part 0]] to get the project created.

This tutorial series is based on the [[http://rogueliketutorials.com][Python Roguelike Tutorial]]. This will be
covering [[http://rogueliketutorials.com/tutorials/tcod/part-1/][Part 1]] of that tutorial as closely as possible, with the exception of
different structure to support more idiomatic Common Lisp, and with using
BearLibTerminal instead of tcod.

*** Opening a window
First we'll work on getting a window created. The Common Lisp bindings we're
using for BearLibTerminal provide some higher level functions to make
interacting with the library more "lispy", so some of the function names won't
align exactly with what you'll see in the BearLibTerminal documentation
(although you can also call those methods, we'll mostly use the high level
functions). You can find the documentation for the high-level API here:
https://sjl.bitbucket.io/cl-blt/reference/.

Open up emacs, and start your REPL. Load your project and change
into your package:

#+BEGIN_SRC common-lisp
(ql:quickload :cl-rltut)
(in-package :cl-rltut)
#+END_SRC

Now in the cl-rltut.lisp file, create a main function to open the window, set
some configs, and enter into a loop:

#+BEGIN_SRC common-lisp
(defparameter *screen-width* 80)
(defparameter *screen-height* 50)

(defun draw ()
  (blt:clear)
  (blt:refresh))

(defun config ()
  (blt:set "window.resizeable = true")
  (blt:set "window.size = ~Ax~A" *screen-width* *screen-height*)
  (blt:set "window.title = Roguelike"))

(defun main()
  (blt:with-terminal
    (config)
    (loop :do
      (draw)
      (blt:key-case (blt:read)
                    (:escape (return))
                    (:close (return))))))
#+END_SRC

If you evaluate the buffer with `sly-eval-buffer`, you will be able to run the
game from your REPL with:
#+BEGIN_SRC common-lisp
(main)
#+END_SRC

If everything was done correctly, you
should see an empty window:

[[/cl-rltut/empty-window.png]]

Exciting! Let's step through the code to see what's going on.

#+BEGIN_SRC common-lisp
(defparameter *screen-width* 80)
(defparameter *screen-height* 50)
#+END_SRC

This creates two global variables to store the width and height of the window,
in cells. By default, the size of the cell is selected based on the font size.

#+BEGIN_SRC common-lisp
(blt:with-terminal ... )
#+END_SRC

This is a macro that wraps the terminal_open and terminal_close functions of the
underlying library. The macro will open a terminal at the start, execute
whatever code we pass within the call, and then close the terminal.

#+BEGIN_SRC common-lisp
(defun config ()
  (blt:set "window.resizeable = true")
  (blt:set "window.size = ~Ax~A" *screen-width* *screen-height*)
  (blt:set "window.title = Roguelike"))
#+END_SRC

The `set` function is how you configure various library options, such as
managing fonts, or setting window settings like we do here. The nice thing about
the Common Lisp wrapper is that it allows the use of format directives to format
the string. We take advantage of that when setting the window.size property to
the width and height variables that we defined earlier. If you're not familiar
with Common Lisp format directives, you can read more about them here: http://www.gigamonkeys.com/book/a-few-format-recipes.html.

#+BEGIN_SRC common-lisp
(loop :do ... )
#+END_SRC

This just starts up an endless loop that our game will run in.

#+BEGIN_SRC common-lisp
(blt:key-case (blt:read)
              (:escape (return))
              (:close (return)))
#+END_SRC

`key-case` is another macro defined in the high level API of the Common Lisp
bindings. This is used to handle keyboard input. As the first parameter, it
takes in an event from the keyboard. We're using the `read` function to get
this data. If there are no events in the input queue, `read` will wait for an
event to come. This blocking behaviour is perfect for our case, because it will
make the turn-based gameplay easier.
The second parameter to the `key-case` macro is a list of clauses. The first
part of a clause, for example :escape, will match with the event returned from
the `read` call. If the event is that the escape button was pressed, then the
second part of the clause wil be executed. In that case, we just return from the
main function to close the program. Only the code in a matching clause will be executed.

#+BEGIN_SRC common-lisp
(defun draw ()
  (blt:clear)
  (blt:refresh))
#+END_SRC

Here we just have a placeholder draw function, which will clear the window to
black and then call `refresh`. All of the drawing that BearLibTerminal does is
to an off-screen buffer, so we won't see our changes displayed until the
`refresh` function is called. While we aren't actually drawing anything yet,
this is needed to make the window visible. BearLibTerminal will only display the
window with the first `refresh` call after opening the window. Prior to that,
the window will stay invisible.

*** Adding the player
Now that we have a window, let's get the player drawn to the screen. Update the
draw function to look like this:

#+BEGIN_SRC common-lisp
(defun draw()
  (blt:clear)
  (setf (blt:color) (blt:white)
        (blt:cell-char 10 10) #\@)
  (blt:refresh))
#+END_SRC

Pretty easy! When blt:color is set, that color will be used for all subsequent
drawing until the color is changed again. Then, we set the cell at 10x10 to the
@ character. If all works, you should see this when you run the game:

[[/cl-rltut/drawing-player.png]]

Next we'll want to be able to move the player around. We're already capturing
some keyboard input, so it won't be difficult to capture the arrow keys as well.
Then we just need to have a way to track the players position so that we can
update it when an arrow key is pressed. Make updates to the following functions:

#+BEGIN_SRC common-lisp
(defun draw (player-x player-y)
  (blt:clear)
  (setf (blt:color) (blt:white)
        (blt:cell-char player-x player-y) #\@)
  (blt:refresh))

(defun handle-keys ()
  (let ((action nil))
    (blt:key-case (blt:read)
                  (:up (setf action (list :move (cons 0 -1))))
                  (:down (setf action (list :move (cons 0 1))))
                  (:left (setf action (list :move (cons -1 0))))
                  (:right (setf action (list :move (cons 1 0))))
                  (:escape (setf action (list :quit t)))
                  (:close (setf action (list :quit t))))
    action))

(defun main()
  (blt:with-terminal
    (config)
    (loop :with player-x = (/ *screen-width* 2)
          :and player-y = (/ *screen-height* 2)
          :do
             (draw player-x player-y)
             (let* ((action (handle-keys))
                    (move (getf action :move))
                    (exit (getf action :quit)))
               (if exit
                   (return))
               (when move
                 (incf player-x (car move))
                 (incf player-y (cdr move)))))))
#+END_SRC

If you run the game now, you should be able to move the player around using the
arrow keys.

We created a new "handle-keys" function, and moved the input handling code into
it. handle-keys returns a property list. When one of the arrow keys is pressed,
the function would return something like:
#+BEGIN_SRC common-lisp
'(:move (0 . 1))
#+END_SRC

When looking at the return value, we can check what type of action is returned
with:
#+BEGIN_SRC common-lisp
(getf action :move)
#+END_SRC

If we run that on the previous example, the result would be the (0 . 1), telling
us that there was a move action to increment the player-y by 1. We can get the x
and y portion of that with the car and cdr functions respectively. If there was no
move action, getf would return nil.

We also added player-x and player-y as local variables on the loop. This will be
changed in the future to add some more structure, but works for now.

*** Conclusion
That's going to be it for this tutorial. You can find the current state of the
code on [[https://github.com/nwforrer/cl-rltut/tree/part-1][Github]]. The list of changes since the previous tutorial can be found at
https://github.com/nwforrer/cl-rltut/compare/part-0...part-1.

Continue to the [[/posts/roguelike-tutorial-part2][part 2]].
** DONE Roguelike tutorial for Common Lisp - Part 2 - Generic entity and map :roguelike::gamedev:lisp:tutorial:
CLOSED: [2019-06-27 Thu 21:53]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part2
:END:
This tutorial series is based on the [[http://rogueliketutorials.com][Python Roguelike Tutorial]]. This will be
covering [[http://rogueliketutorials.com/tutorials/tcod/part-2/][Part 2]] of that tutorial.

It's time to start thinking about how we want to structure our entities, and
what the map will look like. We will be creating a generic entity class that all
entities in the game will use, and introduce the concept of how the map will be
structured. We'll be using classes and generic methods provided with CLOS here.
If you're unfamiliar with CLOS, there is a good overview in [[https://lispcookbook.github.io/cl-cookbook/clos.html][The Common Lisp Cookbook]].

*** Generic entity
The first thing we'll be doing is creating a class to represent entities in the
game, storing it's position, color, and character to render.
#+BEGIN_SRC common-lisp
(defclass entity ()
  ((x :initarg :x :accessor entity/x)
   (y :initarg :y :accessor entity/y)
   (char :initarg :char :accessor entity/char)
   (color :initarg :color :accessor entity/color)))
#+END_SRC

Next we can create some methods on that class to handle drawing and moving the
entity.
#+BEGIN_SRC common-lisp
(defmethod move ((e entity) dx dy)
  (incf (entity/x e) dx)
  (incf (entity/y e) dy))

(defmethod draw ((e entity))
  (with-slots (x y char color) e
    (setf (blt:color) color
          (blt:cell-char x y) char)))
#+END_SRC

We'll rename our old draw function to render-all, and from there call the entities draw
method for each entity.
#+BEGIN_SRC common-lisp
(defun render-all (entities)
  (blt:clear)
  (mapc #'draw entities)
  (blt:refresh))
#+END_SRC
We're just mapping the draw method call over the list of all entities passed
into the function.

Now we actually need to create some entities. Update the main function as
follows:
#+BEGIN_SRC common-lisp
(defun main()
  (blt:with-terminal
    (config)
    (loop :with player = (make-instance 'entity
                                        :x (/ *screen-width* 2)
                                        :y (/ *screen-height* 2)
                                        :char #\@
                                        :color (blt:white))
          :and npc = (make-instance 'entity
                                    :x (- (/ *screen-width* 2) 5)
                                    :y (/ *screen-height* 2)
                                    :char #\@
                                    :color (blt:yellow))
          :with entities = (list player npc)
          :do
             (render-all entities)
             (let* ((action (handle-keys))
                    (move (getf action :move))
                    (exit (getf action :quit)))
               (when exit
                 (return))
               (when move
                 (move player (car move) (cdr move)))))))
#+END_SRC
Here we removed the player-x and player-y variables, and instead create a player
entity. We have also added an npc entity to show how we can use the entity class
for more than just the player. We add those two entities to an entities list,
which gets passed to the render-all function. We also call the new move method
on the player entity when a move action is requested.

If you run the game now, it should look like the following:
[[/cl-rltut/generic-entity-class.png]]

The NPC should look like a yellow @ symbol, and player movement should work like it
did before.

*** Creating the map
Now that we can create and render entities, we should create a map for them to
move around in. We're not going to procedurally generate the map yet (that will
be in the next tutorial), but we'll create the structure needed to render the
map.

Before we do, let's create a new file to store the map related code, as it can
become pretty large once we're generating it. Create a file named
"game-map.lisp" in the root of your project, and declare that it's in the same
package by placing this at the top of the file:
#+BEGIN_SRC common-lisp
(in-package #:cl-rltut)
#+END_SRC

You also need to update the ASDF file to include the new file in your system:
#+BEGIN_SRC common-lisp
(asdf:defsystem #:cl-rltut
  :description "Describe cl-rltut here"
  :author "Nick Forrer"
  :license "MIT"
  :version "0.0.1"
  :serial t
  :depends-on (#:cl-blt)
  :components ((:file "package")
               (:file "cl-rltut")
               (:file "game-map")))
#+END_SRC

In the "game-map.lisp" file, create a new tile class.
#+BEGIN_SRC common-lisp
(defclass tile ()
  ((blocked :initarg :blocked
            :accessor tile/blocked
            :initform nil)
   (block-sight :initarg :block-sight
                :accessor tile/block-sight
                :initform nil)))

(defmethod initialize-instance :after ((tile tile) &rest initargs)
  (declare (ignore initargs))
  (with-slots (blocked block-sight) tile
    (if (null block-sight)
        (setf block-sight blocked))))
#+END_SRC

The blocked slot will indicate whether this tile will block movement, such as if
it represents a wall. The block-sight slot will indicate if this tile will block
an entities vision. These are separate so that we can support things like lava
tiles, where we don't want an entity to walk through it, but they can see past
it. We will implement field-of-vision later, but that will determine which tiles
the player can see at a given time.
We've also defined an after method for initialize-instance for the tile class.
This will be called after a make-instance is called for the class, and the slots
are initialized. Here, we want to make sure the block-sight slot is set to true
if blocked is also true.

Now lets create a game-map class, which will hold a 2D array of tiles to make up
our map.
#+BEGIN_SRC common-lisp
(defclass game-map ()
  ((width :initarg :w :accessor game-map/w)
   (height :initarg :h :accessor game-map/h)
   (tiles :accessor game-map/tiles)))

(defmethod initialize-instance :after ((map game-map) &rest initargs)
  (declare (ignore initargs))
  (setf (game-map/tiles map) (make-array (list (game-map/w map) (game-map/h map)))))
#+END_SRC

We also define an initialize-instance method for game-map. This initializes the
tiles slot to an array with WxH dimensions.

Next create a function to initialize the tiles in the array.
#+BEGIN_SRC common-lisp
(defun initialize-tiles ((map game-map))
  (dotimes (y (game-map/h map))
    (dotimes (x (game-map/w map))
      (setf (aref (game-map/tiles map) x y) (make-instance 'tile))))

  (setf (tile/blocked (aref (game-map/tiles map) 30 22)) t)
  (setf (tile/block-sight (aref (game-map/tiles map) 30 22)) t)
  (setf (tile/blocked (aref (game-map/tiles map) 31 22)) t)
  (setf (tile/block-sight (aref (game-map/tiles map) 31 22)) t)
  (setf (tile/blocked (aref (game-map/tiles map) 32 22)) t)
  (setf (tile/block-sight (aref (game-map/tiles map) 32 22)) t))
#+END_SRC
This loops through all the tiles in the map, and initializes them to a new
instance of the tile class. This will create all the tiles with blocked and
block-sight set to nil. We then set 3 of the tiles to have blocked and
block-sight set to true so we can test it.

We now have a map created, but we can't see it yet. Back in the "cl-rltut.lisp"
file, update the render-all function to take the map as a parameter and render
all it's tiles.
#+BEGIN_SRC common-lisp
(defparameter *color-map* (list :dark-wall (blt:rgba 0 0 100)
                                :dark-ground (blt:rgba 50 50 150)))

(defun render-all (entities map)
  (blt:clear)
  (dotimes (y (game-map/h map))
    (dotimes (x (game-map/w map))
      (let* ((tile (aref (game-map/tiles map) x y))
             (wall (tile/blocked tile)))
        (if wall
            (setf (blt:background-color) (getf *color-map* :dark-wall))
            (setf (blt:background-color) (getf *color-map* :dark-ground))))
      (setf (blt:cell-char x y) #\Space)))

  (mapc #'draw entities)

  (setf (blt:background-color) (blt:black))
  (blt:refresh))
#+END_SRC

We first declare a color-map global variable as a property list to hold a
mapping of keys (like "dark-wall") to their BearLibTerminal color value. This
just makes it easier to reference colors, and easy to update them later if we
wanted to. Then, in the render-all method, we loop over all of the tiles in the
map. We check if the blocked slot is true, and if so, set blt:background-color
to dark-wall. Whenever you set the background-color, all subsequent draw calls
will use it as the background in the cell you draw to. If the tile is not
blocked, we set background-color to dark-ground. We then draw an empty space at
the tiles cell, which will just populate the background of the cell.
After the entire map and all entities are drawn, we reset the background-color
to black.

Now in the main function, lets create a map instance and pass it to the
render-all function to actually see it displayed.
#+BEGIN_SRC common-lisp
(defparameter *map-width* 80)
(defparameter *map-height* 45)

(defparameter *map* nil)

(defun main ()
  (blt:with-terminal
    (config)
    (setf *map* (make-instance 'game-map :w *map-width* :h *map-height*))
    (initialize-tiles *map*)
    (loop :with player = (make-instance 'entity
                                        :x (/ *screen-width* 2)
                                        :y (/ *screen-height* 2)
                                        :char #\@
                                        :color (blt:white))
          :and npc = (make-instance 'entity
                                    :x (- (/ *screen-width* 2) 5)
                                    :y (/ *screen-height* 2)
                                    :char #\@
                                    :color (blt:yellow))
          :with entities = (list player npc)
          :do
             (render-all entities *map*)
             (let* ((action (handle-keys))
                    (move (getf action :move))
                    (exit (getf action :quit)))
               (when exit
                 (return))
               (when move
                 (move player (car move) (cdr move)))))))
#+END_SRC

We create two global variables to hold the map width and height (in cells). The
height is set to 5 cells smaller than the height of the window. This is so that
there is some blank space at the bottom of the window to be used for messages,
which we'll get to in a later tutorial. We also declare the map variable as a
global. This isn't really necessary, and could easily be created as a local
variable in the main function. The reason I've declared it global is so that it
can be looked at and manipulated in the REPL. It's up to you whether you find
that useful enough to make the variable global.
The changes to the main method are straight forward. We initialize an instance
of the game-map class, and initialize it's tiles. Then we just pass it along to
the render-all method to have it displayed.

If you run the game now, it should look like this:
[[/cl-rltut/initial-map-render.png]]

The three dark tiles are the walls. You'll notice that you can still walk
through them, which isn't correct. We can easily fix that by first adding a
helper method in the "game-map-lisp" file:
#+BEGIN_SRC common-lisp
(defmethod blocked-p ((map game-map) x y)
  (tile/blocked (aref (game-map/tiles map) x y)))
#+END_SRC
This takes in the map and an x,y coordinate, and returns whether that tile is
blocked.

We then just need to call that with the coordinates we're moving to, and if it's
blocked, don't move the player. Update the `(when move)` block in the main
function like:
#+BEGIN_SRC common-lisp
(when move
  (unless (blocked-p *map*
                     (+ (entity/x player) (car move))
                     (+ (entity/y player) (cdr move)))
    (move player (car move) (cdr move))))
#+END_SRC

Now if you run the game, it should block you from walking through the walls!

*** Conclusion
That's all for this tutorial. Next we'll be working on procedurally generating
the dungeon map!

You can find the current state of the code on [[https://github.com/nwforrer/cl-rltut/tree/part-2][Github]]. The list of changes since
the previous tutorial can be found at
https://github.com/nwforrer/cl-rltut/compare/part-1...part-2.

Continue to the [[/posts/roguelike-tutorial-part3][part 3]].
** TODO Roguelike tutorial for Common Lisp - Part 3 - Generating a dungeon :roguelike::gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part3
:END:
This tutorial series is based on the [[http://rogueliketutorials.com][Python Roguelike Tutorial]]. This will be
covering [[http://rogueliketutorials.com/tutorials/tcod/part-3/][Part 3]] of that tutorial.

In this post, we'll be procedurally generating the dungeon! We will generate
randomly sized rooms, and connect them with tunnels for the player and npcs to
walk around.
