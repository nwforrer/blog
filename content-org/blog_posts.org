#+HUGO_SECTION: posts
#+HUGO_BASE_DIR: ../
#+author: Nick Forrer

* Hello
** Hello World
:PROPERTIES:
:EXPORT_FILE_NAME: hello-world
:EXPORT_DATE: 2019-06-23
:END:
Testing the site
* Roguelike Tutorials                        :@tutorials:@roguelike_tutorial:
** DONE Roguelike tutorial for Common Lisp - Part 0 - Setup :roguelike:gamedev:lisp:tutorial:
CLOSED: [2019-06-23 Sun 10:24]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part0
:END:
This set of tutorials is going to follow the [[http://rogueliketutorials.com/tutorials/tcod/][Python TCOD tutorial]], but will be
written in Common Lisp and use the BearLibTerminal library.

*** Prior Knowledge
This tutorial assumes you are familiar with programming in Common Lisp. If
you're not familiar, I would highly recommend checking out [[http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/][A Road to Common Lisp]]
on Steve Losh's blog. It provides many valuable resources to get up to speed
with Common Lisp, and is how I got started.
*** Installation
You will need the following installed:
- A Common Lisp implementation. I will be using and testing my code against
  [[http://www.sbcl.org/][SBCL]].
- [[https://www.quicklisp.org/beta/][Quicklisp]]
- An editor. I use Emacs, with the [[https://github.com/hlissner/doom-emacs][Doom Emacs]] configuration.

I run Linux (Fedora) on my machine, and SBCL is available in the default
repositories. If it is not available in your distro (or if you're not running
Linux), check out the [[http://www.sbcl.org/getting.html][getting started]] page.

Quicklisp should be configured based on the installation guide on their [[https://www.quicklisp.org/beta/][home page]].

For the Emacs configuration, the most important peice is to have a REPL
available. I use the [[https://github.com/joaotavora/sly][sly]] package, although [[https://common-lisp.net/project/slime/][SLIME]] is popular as well. Having a
REPL running in your editor makes the development process much more efficient
and enjoyable.

*** Project setup
Once you have everything installed that you need, you can get the project
skeleton created, with the needed dependencies. Since you have Quicklisp
installed, it will be easy to generate a project skeleton using [[https://www.xach.com/lisp/quickproject/][Quickproject]].

First, open emacs and start your REPL (if you're using sly, the Emacs command is
just M-x "sly"). In the REPL:

#+BEGIN_SRC common-lisp
(ql:quickload :quickproject)
(quickproject:make-project #p"cl-rltut" :depends-on '(:cl-blt))
#+END_SRC

That should create a "cl-rltut" directory within the current working
directory of your REPL (this can be shown for sly with the "sly-pwd" command,
and changed with the "sly-cd" command). Within the project directory, you should
see an ASDF file named "cl-rltut.asd", which looks like the following:
#+BEGIN_SRC common-lisp
(asdf:defsystem #:cl-rltut
  :description "Describe cl-rltut here"
  :author "Nick Forrer"
  :license  "MIT"
  :version "0.0.1"
  :serial t
  :depends-on (#:cl-blt)
  :components ((:file "package")
               (:file "cl-rltut")))
#+END_SRC

You will also need to download the cl-blt package, which contains the
Common Lisp bindings for BearLibTerminal. The reason for this is because
cl-blt is not currently available in an online repository that
Quicklisp could download it automatically. Download the package using:

#+BEGIN_SRC sh
git clone https://github.com/sjl/cl-blt.git ~/quicklisp/local-projects/cl-blt
#+END_SRC

That will clone the cl-blt Git repo into a directory that Quicklisp will look at
when trying to load an ASDF system.

In addition to the Common Lisp bindings, you will also need the BearLibTerminal
library itself. Download the appropriate binary for your system from
http://foo.wyrd.name/en:bearlibterminal#download. Once downloaded, extract the
archive and find the shared library dependency. For the Linux archive, this will
be Linux64/libBearLibTerminal.so (assuming you are using a 64-bit OS). This file
should be placed in a "lib" directory in the root of your project.

NOTE: Windows users may need to add the following to their package.lisp file, to
ensure the bearlibterminal library is found:
#+BEGIN_SRC lisp
(cffi:define-foreign-library blt:bearlibterminal
  (t "lib/BearLibTerminal.dll"))

(cffi:use-foreign-library blt:bearlibterminal)
#+END_SRC

To make it easier to load your project from the REPL, you can create a symlink
in the local-projects directly that points to your project, so that Quicklisp
can always find it (use the correct path to your project instead of ~/src/lisp/cl-rltut):

#+BEGIN_SRC sh
ln -s ~/src/lisp/cl-rltut ~/quicklisp/local-projects
#+END_SRC

With all of that in place, you should now be able to load your projects system
in the REPL to ensure in can find all the dependencies with:

#+BEGIN_SRC common-lisp
(ql:quickload :cl-rltut)
#+END_SRC

Assuming you don't see any errors, then your project is all set to continue with
the tutorial! To see what the project should look like at this point, you can
find the current state for Part 0 here: https://github.com/nwforrer/cl-rltut/tree/part-0.

*** Questions and Feedback
If you run into any issues, or have questions/feedback, please open an issue on this
blogs [[https://github.com/nwforrer/blog/issues][GitHub repository]].

Continue to the [[/posts/roguelike-tutorial-part1][next tutorial]].

** DONE Roguelike tutorial for Common Lisp - Part 1 - Drawing the player :roguelike:gamedev:lisp:tutorial:
CLOSED: [2019-06-25 Tue 20:10]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part1
:END:
Welcome to the first part of the tutorial! If you haven't already, please check
out [[/posts/roguelike-tutorial-part0][Part 0]] to get the project created.

This tutorial series is based on the [[http://rogueliketutorials.com][Python Roguelike Tutorial]]. This will be
covering [[http://rogueliketutorials.com/tutorials/tcod/part-1/][Part 1]] of that tutorial as closely as possible, with the exception of
different structure to support more idiomatic Common Lisp, and with using
BearLibTerminal instead of tcod.

*** Opening a window
First we'll work on getting a window created. The Common Lisp bindings we're
using for BearLibTerminal provide some higher level functions to make
interacting with the library more "lispy", so some of the function names won't
align exactly with what you'll see in the BearLibTerminal documentation
(although you can also call those methods, we'll mostly use the high level
functions). You can find the documentation for the high-level API here:
https://sjl.bitbucket.io/cl-blt/reference/.

Open up emacs, and start your REPL. Load your project and change
into your package:

#+BEGIN_SRC common-lisp
(ql:quickload :cl-rltut)
(in-package :cl-rltut)
#+END_SRC

Now in the cl-rltut.lisp file, create a main function to open the window, set
some configs, and enter into a loop:

#+BEGIN_SRC common-lisp
(defparameter *screen-width* 80)
(defparameter *screen-height* 50)

(defun draw ()
  (blt:clear)
  (blt:refresh))

(defun config ()
  (blt:set "window.resizeable = true")
  (blt:set "window.size = ~Ax~A" *screen-width* *screen-height*)
  (blt:set "window.title = Roguelike"))

(defun main()
  (blt:with-terminal
    (config)
    (loop :do
      (draw)
      (blt:key-case (blt:read)
                    (:escape (return))
                    (:close (return))))))
#+END_SRC

If you evaluate the buffer with `sly-eval-buffer`, you will be able to run the
game from your REPL with:
#+BEGIN_SRC common-lisp
(main)
#+END_SRC

If everything was done correctly, you
should see an empty window:

[[/cl-rltut/empty-window.png]]

Exciting! Let's step through the code to see what's going on.

#+BEGIN_SRC common-lisp
(defparameter *screen-width* 80)
(defparameter *screen-height* 50)
#+END_SRC

This creates two global variables to store the width and height of the window,
in cells. By default, the size of the cell is selected based on the font size.

#+BEGIN_SRC common-lisp
(blt:with-terminal ... )
#+END_SRC

This is a macro that wraps the terminal_open and terminal_close functions of the
underlying library. The macro will open a terminal at the start, execute
whatever code we pass within the call, and then close the terminal.

#+BEGIN_SRC common-lisp
(defun config ()
  (blt:set "window.resizeable = true")
  (blt:set "window.size = ~Ax~A" *screen-width* *screen-height*)
  (blt:set "window.title = Roguelike"))
#+END_SRC

The `set` function is how you configure various library options, such as
managing fonts, or setting window settings like we do here. The nice thing about
the Common Lisp wrapper is that it allows the use of format directives to format
the string. We take advantage of that when setting the window.size property to
the width and height variables that we defined earlier. If you're not familiar
with Common Lisp format directives, you can read more about them here: http://www.gigamonkeys.com/book/a-few-format-recipes.html.

#+BEGIN_SRC common-lisp
(loop :do ... )
#+END_SRC

This just starts up an endless loop that our game will run in.

#+BEGIN_SRC common-lisp
(blt:key-case (blt:read)
              (:escape (return))
              (:close (return)))
#+END_SRC

`key-case` is another macro defined in the high level API of the Common Lisp
bindings. This is used to handle keyboard input. As the first parameter, it
takes in an event from the keyboard. We're using the `read` function to get
this data. If there are no events in the input queue, `read` will wait for an
event to come. This blocking behaviour is perfect for our case, because it will
make the turn-based gameplay easier.
The second parameter to the `key-case` macro is a list of clauses. The first
part of a clause, for example :escape, will match with the event returned from
the `read` call. If the event is that the escape button was pressed, then the
second part of the clause wil be executed. In that case, we just return from the
main function to close the program. Only the code in a matching clause will be executed.

#+BEGIN_SRC common-lisp
(defun draw ()
  (blt:clear)
  (blt:refresh))
#+END_SRC

Here we just have a placeholder draw function, which will clear the window to
black and then call `refresh`. All of the drawing that BearLibTerminal does is
to an off-screen buffer, so we won't see our changes displayed until the
`refresh` function is called. While we aren't actually drawing anything yet,
this is needed to make the window visible. BearLibTerminal will only display the
window with the first `refresh` call after opening the window. Prior to that,
the window will stay invisible.

*** Adding the player
Now that we have a window, let's get the player drawn to the screen. Update the
draw function to look like this:

#+BEGIN_SRC common-lisp
(defun draw()
  (blt:clear)
  (setf (blt:color) (blt:white)
        (blt:cell-char 10 10) #\@)
  (blt:refresh))
#+END_SRC

Pretty easy! When blt:color is set, that color will be used for all subsequent
drawing until the color is changed again. Then, we set the cell at 10x10 to the
@ character. If all works, you should see this when you run the game:

[[/cl-rltut/drawing-player.png]]

Next we'll want to be able to move the player around. We're already capturing
some keyboard input, so it won't be difficult to capture the arrow keys as well.
Then we just need to have a way to track the players position so that we can
update it when an arrow key is pressed. Make updates to the following functions:

#+BEGIN_SRC common-lisp
(defun draw (player-x player-y)
  (blt:clear)
  (setf (blt:color) (blt:white)
        (blt:cell-char player-x player-y) #\@)
  (blt:refresh))

(defun handle-keys ()
  (let ((action nil))
    (blt:key-case (blt:read)
                  (:up (setf action (list :move (cons 0 -1))))
                  (:down (setf action (list :move (cons 0 1))))
                  (:left (setf action (list :move (cons -1 0))))
                  (:right (setf action (list :move (cons 1 0))))
                  (:escape (setf action (list :quit t)))
                  (:close (setf action (list :quit t))))
    action))

(defun main()
  (blt:with-terminal
    (config)
    (loop :with player-x = (/ *screen-width* 2)
          :and player-y = (/ *screen-height* 2)
          :do
             (draw player-x player-y)
             (let* ((action (handle-keys))
                    (move (getf action :move))
                    (exit (getf action :quit)))
               (if exit
                   (return))
               (when move
                 (incf player-x (car move))
                 (incf player-y (cdr move)))))))
#+END_SRC

If you run the game now, you should be able to move the player around using the
arrow keys.

We created a new "handle-keys" function, and moved the input handling code into
it. handle-keys returns a property list. When one of the arrow keys is pressed,
the function would return something like:
#+BEGIN_SRC common-lisp
'(:move (0 . 1))
#+END_SRC

When looking at the return value, we can check what type of action is returned
with:
#+BEGIN_SRC common-lisp
(getf action :move)
#+END_SRC

If we run that on the previous example, the result would be the (0 . 1), telling
us that there was a move action to increment the player-y by 1. We can get the x
and y portion of that with the car and cdr functions respectively. If there was no
move action, getf would return nil.

We also added player-x and player-y as local variables on the loop. This will be
changed in the future to add some more structure, but works for now.

*** Conclusion
That's going to be it for this tutorial. You can find the current state of the
code on [[https://github.com/nwforrer/cl-rltut/tree/part-1][Github]]. The list of changes since the previous tutorial can be found at
https://github.com/nwforrer/cl-rltut/compare/part-0...part-1.

If you run into any issues, or have questions/feedback, please open an issue on this
blogs [[https://github.com/nwforrer/blog/issues][GitHub repository]].

Continue to the [[/posts/roguelike-tutorial-part2][part 2]].
** DONE Roguelike tutorial for Common Lisp - Part 2 - Generic entity and map :roguelike:gamedev:lisp:tutorial:
CLOSED: [2019-06-27 Thu 21:53]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part2
:END:
This tutorial series is based on the [[http://rogueliketutorials.com][Python Roguelike Tutorial]]. This will be
covering [[http://rogueliketutorials.com/tutorials/tcod/part-2/][Part 2]] of that tutorial.

It's time to start thinking about how we want to structure our entities, and
what the map will look like. We will be creating a generic entity class that all
entities in the game will use, and introduce the concept of how the map will be
structured. We'll be using classes and generic methods provided with CLOS here.
If you're unfamiliar with CLOS, there is a good overview in [[https://lispcookbook.github.io/cl-cookbook/clos.html][The Common Lisp Cookbook]].

*** Generic entity
The first thing we'll be doing is creating a class to represent entities in the
game, storing it's position, color, and character to render.
#+BEGIN_SRC common-lisp
(defclass entity ()
  ((x :initarg :x :accessor entity/x)
   (y :initarg :y :accessor entity/y)
   (char :initarg :char :accessor entity/char)
   (color :initarg :color :accessor entity/color)))
#+END_SRC

Next we can create some methods on that class to handle drawing and moving the
entity.
#+BEGIN_SRC common-lisp
(defmethod move ((e entity) dx dy)
  (incf (entity/x e) dx)
  (incf (entity/y e) dy))

(defmethod draw ((e entity))
  (with-slots (x y char color) e
    (setf (blt:color) color
          (blt:cell-char x y) char)))
#+END_SRC

We'll rename our old draw function to render-all, and from there call the entities draw
method for each entity.
#+BEGIN_SRC common-lisp
(defun render-all (entities)
  (blt:clear)
  (mapc #'draw entities)
  (blt:refresh))
#+END_SRC
We're just mapping the draw method call over the list of all entities passed
into the function.

Now we actually need to create some entities. Update the main function as
follows:
#+BEGIN_SRC common-lisp
(defun main()
  (blt:with-terminal
    (config)
    (loop :with player = (make-instance 'entity
                                        :x (/ *screen-width* 2)
                                        :y (/ *screen-height* 2)
                                        :char #\@
                                        :color (blt:white))
          :and npc = (make-instance 'entity
                                    :x (- (/ *screen-width* 2) 5)
                                    :y (/ *screen-height* 2)
                                    :char #\@
                                    :color (blt:yellow))
          :with entities = (list player npc)
          :do
             (render-all entities)
             (let* ((action (handle-keys))
                    (move (getf action :move))
                    (exit (getf action :quit)))
               (when exit
                 (return))
               (when move
                 (move player (car move) (cdr move)))))))
#+END_SRC
Here we removed the player-x and player-y variables, and instead create a player
entity. We have also added an npc entity to show how we can use the entity class
for more than just the player. We add those two entities to an entities list,
which gets passed to the render-all function. We also call the new move method
on the player entity when a move action is requested.

If you run the game now, it should look like the following:
[[/cl-rltut/generic-entity-class.png]]

The NPC should look like a yellow @ symbol, and player movement should work like it
did before.

*** Creating the map
Now that we can create and render entities, we should create a map for them to
move around in. We're not going to procedurally generate the map yet (that will
be in the next tutorial), but we'll create the structure needed to render the
map.

Before we do, let's create a new file to store the map related code, as it can
become pretty large once we're generating it. Create a file named
"game-map.lisp" in the root of your project, and declare that it's in the same
package by placing this at the top of the file:
#+BEGIN_SRC common-lisp
(in-package #:cl-rltut)
#+END_SRC

You also need to update the ASDF file to include the new file in your system:
#+BEGIN_SRC common-lisp
(asdf:defsystem #:cl-rltut
  :description "Describe cl-rltut here"
  :author "Nick Forrer"
  :license "MIT"
  :version "0.0.1"
  :serial t
  :depends-on (#:cl-blt)
  :components ((:file "package")
               (:file "cl-rltut")
               (:file "game-map")))
#+END_SRC

In the "game-map.lisp" file, create a new tile class.
#+BEGIN_SRC common-lisp
(defclass tile ()
  ((blocked :initarg :blocked
            :accessor tile/blocked
            :initform nil)
   (block-sight :initarg :block-sight
                :accessor tile/block-sight
                :initform nil)))

(defmethod initialize-instance :after ((tile tile) &rest initargs)
  (declare (ignore initargs))
  (with-slots (blocked block-sight) tile
    (if (null block-sight)
        (setf block-sight blocked))))
#+END_SRC

The blocked slot will indicate whether this tile will block movement, such as if
it represents a wall. The block-sight slot will indicate if this tile will block
an entities vision. These are separate so that we can support things like lava
tiles, where we don't want an entity to walk through it, but they can see past
it. We will implement field-of-vision later, but that will determine which tiles
the player can see at a given time.
We've also defined an after method for initialize-instance for the tile class.
This will be called after a make-instance is called for the class, and the slots
are initialized. Here, we want to make sure the block-sight slot is set to true
if blocked is also true.

Now lets create a game-map class, which will hold a 2D array of tiles to make up
our map.
#+BEGIN_SRC common-lisp
(defclass game-map ()
  ((width :initarg :w :accessor game-map/w)
   (height :initarg :h :accessor game-map/h)
   (tiles :accessor game-map/tiles)))

(defmethod initialize-instance :after ((map game-map) &rest initargs)
  (declare (ignore initargs))
  (setf (game-map/tiles map) (make-array (list (game-map/w map) (game-map/h map)))))
#+END_SRC

We also define an initialize-instance method for game-map. This initializes the
tiles slot to an array with WxH dimensions.

Next create a function to initialize the tiles in the array.
#+BEGIN_SRC common-lisp
(defun initialize-tiles ((map game-map))
  (dotimes (y (game-map/h map))
    (dotimes (x (game-map/w map))
      (setf (aref (game-map/tiles map) x y) (make-instance 'tile))))

  (setf (tile/blocked (aref (game-map/tiles map) 30 22)) t)
  (setf (tile/block-sight (aref (game-map/tiles map) 30 22)) t)
  (setf (tile/blocked (aref (game-map/tiles map) 31 22)) t)
  (setf (tile/block-sight (aref (game-map/tiles map) 31 22)) t)
  (setf (tile/blocked (aref (game-map/tiles map) 32 22)) t)
  (setf (tile/block-sight (aref (game-map/tiles map) 32 22)) t))
#+END_SRC
This loops through all the tiles in the map, and initializes them to a new
instance of the tile class. This will create all the tiles with blocked and
block-sight set to nil. We then set 3 of the tiles to have blocked and
block-sight set to true so we can test it.

We now have a map created, but we can't see it yet. Back in the "cl-rltut.lisp"
file, update the render-all function to take the map as a parameter and render
all it's tiles.
#+BEGIN_SRC common-lisp
(defparameter *color-map* (list :dark-wall (blt:rgba 0 0 100)
                                :dark-ground (blt:rgba 50 50 150)))

(defun render-all (entities map)
  (blt:clear)
  (dotimes (y (game-map/h map))
    (dotimes (x (game-map/w map))
      (let* ((tile (aref (game-map/tiles map) x y))
             (wall (tile/blocked tile)))
        (if wall
            (setf (blt:background-color) (getf *color-map* :dark-wall))
            (setf (blt:background-color) (getf *color-map* :dark-ground))))
      (setf (blt:cell-char x y) #\Space)))

  (mapc #'draw entities)

  (setf (blt:background-color) (blt:black))
  (blt:refresh))
#+END_SRC

We first declare a color-map global variable as a property list to hold a
mapping of keys (like "dark-wall") to their BearLibTerminal color value. This
just makes it easier to reference colors, and easy to update them later if we
wanted to. Then, in the render-all method, we loop over all of the tiles in the
map. We check if the blocked slot is true, and if so, set blt:background-color
to dark-wall. Whenever you set the background-color, all subsequent draw calls
will use it as the background in the cell you draw to. If the tile is not
blocked, we set background-color to dark-ground. We then draw an empty space at
the tiles cell, which will just populate the background of the cell.
After the entire map and all entities are drawn, we reset the background-color
to black.

Now in the main function, lets create a map instance and pass it to the
render-all function to actually see it displayed.
#+BEGIN_SRC common-lisp
(defparameter *map-width* 80)
(defparameter *map-height* 45)

(defparameter *map* nil)

(defun main ()
  (blt:with-terminal
    (config)
    (setf *map* (make-instance 'game-map :w *map-width* :h *map-height*))
    (initialize-tiles *map*)
    (loop :with player = (make-instance 'entity
                                        :x (/ *screen-width* 2)
                                        :y (/ *screen-height* 2)
                                        :char #\@
                                        :color (blt:white))
          :and npc = (make-instance 'entity
                                    :x (- (/ *screen-width* 2) 5)
                                    :y (/ *screen-height* 2)
                                    :char #\@
                                    :color (blt:yellow))
          :with entities = (list player npc)
          :do
             (render-all entities *map*)
             (let* ((action (handle-keys))
                    (move (getf action :move))
                    (exit (getf action :quit)))
               (when exit
                 (return))
               (when move
                 (move player (car move) (cdr move)))))))
#+END_SRC

We create two global variables to hold the map width and height (in cells). The
height is set to 5 cells smaller than the height of the window. This is so that
there is some blank space at the bottom of the window to be used for messages,
which we'll get to in a later tutorial. We also declare the map variable as a
global. This isn't really necessary, and could easily be created as a local
variable in the main function. The reason I've declared it global is so that it
can be looked at and manipulated in the REPL. It's up to you whether you find
that useful enough to make the variable global.
The changes to the main method are straight forward. We initialize an instance
of the game-map class, and initialize it's tiles. Then we just pass it along to
the render-all method to have it displayed.

If you run the game now, it should look like this:
[[/cl-rltut/initial-map-render.png]]

The three dark tiles are the walls. You'll notice that you can still walk
through them, which isn't correct. We can easily fix that by first adding a
helper method in the "game-map-lisp" file:
#+BEGIN_SRC common-lisp
(defmethod blocked-p ((map game-map) x y)
  (tile/blocked (aref (game-map/tiles map) x y)))
#+END_SRC
This takes in the map and an x,y coordinate, and returns whether that tile is
blocked.

We then just need to call that with the coordinates we're moving to, and if it's
blocked, don't move the player. Update the `(when move)` block in the main
function like:
#+BEGIN_SRC common-lisp
(when move
  (unless (blocked-p *map*
                     (+ (entity/x player) (car move))
                     (+ (entity/y player) (cdr move)))
    (move player (car move) (cdr move))))
#+END_SRC

Now if you run the game, it should block you from walking through the walls!

*** Conclusion
That's all for this tutorial. Next we'll be working on procedurally generating
the dungeon map!

You can find the current state of the code on [[https://github.com/nwforrer/cl-rltut/tree/part-2][Github]]. The list of changes since
the previous tutorial can be found at
https://github.com/nwforrer/cl-rltut/compare/part-1...part-2.

If you run into any issues, or have questions/feedback, please open an issue on this
blogs [[https://github.com/nwforrer/blog/issues][GitHub repository]].

Continue to the [[/posts/roguelike-tutorial-part3][part 3]].
** DONE Roguelike tutorial for Common Lisp - Part 3 - Generating a dungeon :roguelike:gamedev:lisp:tutorial:
CLOSED: [2019-07-05 Fri 17:05]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part3
:END:
This tutorial series is based on the [[http://rogueliketutorials.com][Python Roguelike Tutorial]]. This will be
covering [[http://rogueliketutorials.com/tutorials/tcod/part-3/][Part 3]] of that tutorial.

In this post, we'll be procedurally generating the dungeon! We will generate
randomly sized rooms, and connect them with tunnels for the player and npcs to
walk around.

*** Looping over tiles
First things first, we're going to set all tiles to blocked by default.
Previously, we had all tiles set as floors, and placed a couple of walls to
test. Most dungeon generation algorithms work in the opposite way. They first
block all tiles, and then procedurally carve out rooms and corridors.

Update the initialize-tiles method to match the following:
#+BEGIN_SRC common-lisp
(defmethod initialize-tiles ((map game-map))
  (dotimes (y (game-map/h map))
    (dotimes (x (game-map/w map))
      (setf (aref (game-map/tiles map) x y) (make-instance 'tile :blocked t)))))
#+END_SRC

Looping over tiles like this is going to be something that happens a few times.
To make this easier, we can define a macro that will loop over all tiles (or a
subsection of tiles), and assign the current tile to a variable for us to use.
The macro looks like this:

#+BEGIN_SRC common-lisp
(defmacro map-tiles-loop ((map tile-val &key (row-val (gensym)) (col-val (gensym)) (x-start 0) (y-start 0) (x-end nil) (y-end nil)) &body body)
  `(loop :for ,col-val :from ,x-start :below (if (null ,x-end) (game-map/w ,map) ,x-end)
         :do
            (loop :for ,row-val :from ,y-start :below (if (null ,y-end) (game-map/h ,map) ,y-end)
                  :do
                     (let ((,tile-val (aref (game-map/tiles ,map) ,col-val ,row-val)))
                       (declare (ignorable ,tile-val))
                       ,@body))))
#+END_SRC

The macro takes in a map with all the tiles initialized, a tile-val which holds
the name you want to use for the variable that holds the current tile. It also
takes in some optional parameters via keys: row-val and col-val represent the
names of the x and y variables if you want to access them within the body of the
macro. If not supplied, they are generated. x-start, y-start, x-end, and y-end
allow you to specify the start and end of the tile array to loop over. By
default, it loops over all the tiles.

To see this in use, we can update the initialize-tiles method:
#+BEGIN_SRC common-lisp
(defmethod initialize-tiles ((map game-map))
  (map-tiles-loop (map tile :col-val x :row-val y)
    (setf (aref (game-map/tiles map) x y) (make-instance 'tile :blocked t))))
#+END_SRC

If we were to expand the macro, it looks like this:
#+BEGIN_SRC common-lisp
(loop :for x :from 0 :below (if (null nil)
                                  (game-map/w map)
                                  nil)
        :do (loop :for y :from 0 :below (if (null nil)
                                            (game-map/h map)
                                            nil)
                  :do (let ((tile (aref (game-map/tiles map) x y)))
                        (declare (ignorable tile))
                        (setf (aref (game-map/tiles map) x y)
                                (make-instance 'tile :blocked
                                               initial-blocked-value)))))
#+END_SRC

*** Defining rooms and tunnels

Before we get into the map generation, let's create a helper class that we'll
use to represent rooms:
#+BEGIN_SRC common-lisp
(defclass rect ()
  ((x1 :initarg :x1 :accessor rect/x1)
   (x2 :initarg :x2 :accessor rect/x2)
   (y1 :initarg :y1 :accessor rect/y1)
   (y2 :initarg :y2 :accessor rect/y2)))

(defmethod initialize-instance :after ((rect rect) &key x y w h)
  (with-slots (x1 x2 y1 y2) rect
    (setf x1 x
          y1 y
          x2 (+ x w)
          y2 (+ y h))))
#+END_SRC

rect holds the values to represent the top left and bottom right corners of the
rectangle. We also defined the initialize-instance method for the class, and
allowed x y w h to be passed in, making it easier to create an instance of the class.

Now we can carve rooms into the map:
#+BEGIN_SRC common-lisp
(defmethod set-tile-slots ((tile tile) &key (blocked nil blocked-supplied-p) (block-sight nil block-sight-supplied-p))
  (if blocked-supplied-p
      (setf (slot-value tile 'blocked) blocked))
  (if block-sight-supplied-p
      (setf (slot-value tile 'block-sight) block-sight)))

(defmethod create-room ((map game-map) (room rect))
  (map-tiles-loop (map tile
                   :x-start (1+ (rect/x1 room)) :x-end (rect/x2 room)
                   :y-start (1+ (rect/y1 room)) :y-end (rect/y2 room))
    (set-tile-slots tile :blocked nil :block-sight nil)))
#+END_SRC

We make sure to leave the border of the room untouched, which is why the loop
starts at x1/y1 + 1, and the ending x2/y2 is excluded (remember, the
map-tiles-loop macro uses :below in the loop). This ensures that if we make two
rooms next to each other, one starting at (1,1) going to (6,6), and the other
starting at (7,1) going to (9,6) there will still be a wall in between them.
Otherwise, it would look like one room instead of two rooms.

Now, let's make a couple rooms to test. Create the following method:
#+BEGIN_SRC common-lisp
(defmethod make-map ((map game-map))
  (let ((room-1 (make-instance 'rect :x 20 :y 15 :w 10 :h 15))
        (room-2 (make-instance 'rect :x 35 :y 15 :w 10 :h 15)))
    (create-room map room-1)
    (create-room map room-2)))
#+END_SRC

In order to call this method in our main function, we're going to update our
game loop structure a bit. We'll add a new game-tick function, and update the main function to look like this:
#+BEGIN_SRC common-lisp
(defun game-tick (player entities map)
  (render-all entities map)
  (let* ((action (handle-keys))
         (move (getf action :move))
         (exit (getf action :quit)))
    (when move
      (unless (blocked-p map
                         (+ (entity/x player) (car move))
                         (+ (entity/y player) (cdr move)))
        (move player (car move) (cdr move))))

    exit))

(defun main ()
  (blt:with-terminal
      (config)
    (let ((player (make-instance 'entity
                                  :x (/ *screen-width* 2)
                                  :y (/ *screen-height* 2)
                                  :char #\@
                                  :color (blt:white)))
          (npc (make-instance 'entity
                               :x (- (/ *screen-width* 2) 5)
                               :y (/ *screen-height* 2)
                               :char #\@
                               :color (blt:yellow)))
          (entities (list player npc))
          (map (make-instance 'game-map :w *map-width* :h *map-height*)))
      (make-map (map))

      (do ((exit nil (game-tick player entities map)))
          (exit)))))
#+END_SRC

You can also remove the *map* global variable we had before, as we now create
the map locally. While we're at it, we don't really need the initialize-tiles method in the
game-map.lisp file. Since we always want the tiles initialized, we'll move that
code into the initialize-instance method:
#+BEGIN_SRC common-lisp
(defmethod initialize-instance :after ((map game-map) &key (initial-blocked-value t))
  (setf (game-map/tiles map) (make-array (list (game-map/w map) (game-map/h map))))
  (map-tiles-loop (map tile :col-val x :row-val y)
                  (setf (aref (game-map/tiles map) x y) (make-instance 'tile :blocked initial-blocked-value))))
#+END_SRC

Now if you run the game, it should look like this:
[[/cl-rltut/create-test-rooms.png]]

With the rooms being created, we should also create tunnels to connect them.
For our generation code, the tunnels will just be a combination of a horizontal
and vertical section, so there won't be any winding tunnels. Add the following
two methods:
#+BEGIN_SRC common-lisp
(defmethod create-h-tunnel ((map game-map) x1 x2 y)
  (let ((start-x (min x1 x2))
        (end-x (max x1 x2)))
    (map-tiles-loop (map tile
                     :x-start start-x :x-end (1+ end-x)
                     :y-start y :y-end (1+ y))
      (set-tile-slots tile :blocked nil :block-sight nil))))

(defmethod create-v-tunnel ((map game-map) y1 y2 x)
  (let ((start-y (min y1 y2))
        (end-y (max y1 y2)))
    (map-tiles-loop (map tile
                     :x-start x :x-end (1+ x)
                     :y-start start-y :y-end (1+ end-y))
      (set-tile-slots tile :blocked nil :block-sight nil))))
#+END_SRC

Let's test it out by updating our make-map method:
#+BEGIN_SRC common-lisp
(defmethod make-map ((map game-map))
  (let ((room-1 (make-instance 'rect :x 20 :y 15 :w 10 :h 15))
        (room-2 (make-instance 'rect :x 35 :y 15 :w 10 :h 15)))
    (create-room map room-1)
    (create-room map room-2))

  (create-h-tunnel map 25 40 23))
#+END_SRC

Running the game now should look like:
[[/cl-rltut/test-tunnel.png]]
*** Generating the dungeon
Now that we can create rooms and tunnels, it's time to move on to the actual
dungeon generation. It will be relatively basic: we'll create a bunch of rooms,
make sure they don't overlap, and connect them together.

First, add a couple methods to the rect class to assist with detecting when two
rooms overlap:
#+BEGIN_SRC common-lisp
(defmethod center ((rect rect))
  (with-slots (x1 x2 y1 y2) rect
    (let ((center-x (round (/ (+ x1 x2) 2)))
          (center-y (round (/ (+ y1 y2) 2))))
      (values center-x center-y))))

(defmethod intersect ((rect rect) (other rect))
  "Returns T if this RECT intersects with OTHER"
  (and (<= (rect/x1 rect) (rect/x2 other))
       (>= (rect/x2 rect) (rect/x1 other))
       (<= (rect/y1 rect) (rect/y2 other))
       (>= (rect/y2 rect) (rect/y1 other))))
#+END_SRC

Add a couple of variables to the cl-rltut.lisp file, to use with our generation:
#+BEGIN_SRC common-lisp
(defparameter *room-max-size* 10)
(defparameter *room-min-size* 6)
(defparameter *max-rooms* 30)
#+END_SRC

Now, update the make-map method signature to take in those variables, and start
calculating the position and size for the rooms:
#+BEGIN_SRC common-lisp
(defmethod make-map ((map game-map) max-rooms room-min-size room-max-size map-width map-height player)
  (do* ((rooms nil)
        (num-rooms 0)
        (room-index 0 (1+ room-index))
        (w (+ (random (- room-max-size room-min-size)) room-min-size)
           (+ (random (- room-max-size room-min-size)) room-min-size))
        (h (+ (random (- room-max-size room-min-size)) room-min-size)
           (+ (random (- room-max-size room-min-size)) room-min-size))
        (x (random (- map-width w))
           (random (- map-width w)))
        (y (random (- map-height h))
           (random (- map-height h)))
        (new-room (make-instance 'rect :x x :y y :w w :h h)
                  (make-instance 'rect :x x :y y :w w :h h))
        (can-place-p t t))
       ((>= room-index max-rooms))))
#+END_SRC

We're calculating each room's width and height as a random size between the
room-min-size and room-max-size. The x and y position is a random point within
the map. We then create a new-room variable with these calculated values. The
rooms variable is going to hold all the rooms that we create, so we can check
for overlaps, and the room-index and num-rooms will help with looking up the
previous room. When we generate the tunnels, we'll just be connecting the
current room to the previously created room.

Update the do* body to check for intersections:
#+BEGIN_SRC common-lisp
(dolist (other-room rooms)
  (if (intersect new-room other-room)
      (setf can-place-p nil)))
#+END_SRC

That just loops over the rooms list (which we'll populate later), and checks if
the current room we're placing intersects with any of the other rooms. If there
is an intersection, we're setting the can-place-p variable to show that we
shouldn't actually create this room.

After that dolist loop, we can create the new room, and connect it to the
previous room:
#+BEGIN_SRC common-lisp
(when can-place-p
  (create-room map new-room)
  (multiple-value-bind (new-x new-y) (center new-room)
    (if (zerop num-rooms)
        (setf (entity/x player) new-x
              (entity/y player) new-y)
        (multiple-value-bind (prev-x prev-y) (center (car (last rooms)))
          (cond ((= (random 2) 1)
                 (create-h-tunnel map prev-x new-x prev-y)
                 (create-v-tunnel map prev-y new-y new-x))
                (t
                 (create-v-tunnel map prev-y new-y prev-x)
                 (create-h-tunnel map prev-x new-x new-y)))))
    (if (null rooms)
        (setf rooms (list new-room))
        (push new-room (cdr (last rooms))))
    (incf num-rooms)))
#+END_SRC

The tunnel creation randomly decides whether to use a horizontal or vertical
tunnel first, so that it doesn't look so uniform. The tunnel is created from the
center of the previous room, to the center of the new room. After the room is
created, it's added to the rooms list so that we can check for overlaps in the
next rooms.

Running the code now, you should see a complete dungeon:
[[/cl-rltut/dungeon-generation.png]]

Note that since it's randomly generated, your output won't look exactly the same.

*** Conclusion
That's all there is to it. It's a pretty simple algorithm, but gives decent
results. There are plenty of other algorithms to generate different looking
dungeons. For example, you can use a type of [[http://journal.stuffwithstuff.com/2014/12/21/rooms-and-mazes/][maze algorithm]] to make the tunnels
between rooms more interesting.

You can find the current state of the code on [[https://github.com/nwforrer/cl-rltut/tree/part-3][Github]]. The list of changes since
the previous tutorial can be found at
[[https://github.com/nwforrer/cl-rltut/compare/part-2...part-3]].

If you run into any issues, or have questions/feedback, please open an issue on this
blogs [[https://github.com/nwforrer/blog/issues][GitHub repository]].

Continue to [[/posts/roguelike-tutorial-part4][part 4]].
** DONE Roguelike tutorial for Common Lisp - Part 4 - Field of view :roguelike:gamedev:lisp:tutorial:
CLOSED: [2019-07-14 Sun 22:43]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part4
:END:
This tutorial series is based on the [[http://rogueliketutorials.com][Python Roguelike Tutorial]]. This will be
covering [[http://rogueliketutorials.com/tutorials/tcod/part-4/][Part 4]] of that tutorial.

In this post, we'll be computing the Field Of View (FOV) of the player. This
will make exploring the dungeon much more interesting. When the game starts,
only the tiles near the player will be visible. As the player explores the
dungeon, the tiles that the player moves past will also become visible, allowing
the map to be shown. However, any items or enemies will only be visible if they
are within the players sight at a given time. Once the player moves on, the
item/enemy will no longer be displayed.

This post will differ from the Python Roguelike Tutorial more-so than previous
posts. In the Python Tutorial, the libtcod library is being used, which provides
FOV algorithms to calculate the FOV for you. However, we're using
BearLibTerminal which does not have such algorithms. We could import the libtcod
library to take advantage of those algorithms, but where's the fun in that?
Instead we'll be writing the algorithm from scratch. The reference I'm using
for this is:
[[http://www.roguebasin.com/index.php?title=Line_of_Sight_-_Tobias_Downer][http://www.roguebasin.com/index.php?title=Line_of_Sight_-_Tobias_Downer]].
RogueBasin has many [[http://www.roguebasin.com/index.php?title=Category:FOV][articles and techniques]] for calculating the FOV. We'll be
taking a very simplistic approach, which will work well enough for our needs.

*** Calculating the Field of View
First, we'll need a way to track which tiles are visible to the player, so that
we can render them differently from the non-visible tiles:
#+BEGIN_SRC common-lisp
(defclass tile ()
  ((blocked :initarg :blocked
            :accessor tile/blocked
            :initform nil)
   (block-sight :initarg :block-sight
                :accessor tile/block-sight
                :initform nil)
   (visible :initarg :visible
            :accessor tile/visible
            :initform nil)))
#+END_SRC

The way the algorithm works, is we'll start at the player's position, trace rays
in every direction, and check each tile that the ray intersects with. If the
tile's block-sight slot is set to nil, then we'll set it's visible slot to t.
Once a ray reaches a tile that has block-site set to t, then we stop tracing
that ray, so all the tiles after it have their visible tiles set to nil.

Create a new file named fov.lisp, and create a fov function, and a way to reset
the visible slot on all tiles:
#+BEGIN_SRC common-lisp
(defparameter *fov-distance* 5)

(defun reset-visibility (map)
  (map-tiles-loop (map tile)
    (setf (tile/visible tile) nil)))

(defun fov (map x y)
  (reset-visibility map))
#+END_SRC

Now, we'll trace 360 lines around the player's position, one for each degree of
a circle. Each line will be `fov-distance` long. We will use [[https://en.wikipedia.org/wiki/Linear_interpolation][linear
interpolation]] to take incremential steps over the line. At each step, we'll
check that we haven't gone outside the bounds of the map, and then check if the
tile at that step has block-sight set to t. If neither of those are true, then
the tile must be visible. The full function looks like this:
#+BEGIN_SRC common-lisp
(defun degree-to-radian (degree)
  (* degree (/ pi 180)))

(defun diagonal-distance (x0 y0 x1 y1)
  (let ((dx (- x0 x1))
        (dy (- y1 y0)))
    (max (abs dx) (abs dy))))

(defun lerp (start end time)
  (+ start (* time (- end start))))

(defun fov (map x y)
  (reset-visibility map)

  ;; loop aver 360 degrees
  (dotimes (degree 360)
    (let* ((rad (degree-to-radian degree))
           (nx (round (+ (* (cos rad) *fov-distance*) x)))
           (ny (round (+ (* (sin rad) *fov-distance*) y)))
           (d (diagonal-distance x y nx ny)))
      (dotimes (tile d)
        (let ((tx (round (lerp x nx (/ tile d))))
              (ty (round (lerp y ny (/ tile d)))))
          (if (or (< tx 0) (> tx (game-map/w map)))
              (return))
          (if (or (< ty 0) (> ty (game-map/h map)))
              (return))

          ;; if tile is a wall, mark as seen and stop the line early
          (when (tile/block-sight (aref (game-map/tiles map) tx ty))
            (setf (tile/visible (aref (game-map/tiles map) tx ty)) t)
            (return))

          (setf (tile/visible (aref (game-map/tiles map) tx ty)) t))))))
#+END_SRC

*** Rendering the field of view
Now that we know which tiles are visible to the player, we can update our
rendering to display them differently. Update the color map to include the
colors we'll use to display the visible floors and walls:
#+BEGIN_SRC common-lisp
(defparameter *color-map* (list :dark-wall (blt:rgba 0 0 100)
                                :dark-ground (blt:rgba 50 50 150)
                                :light-wall (blt:rgba 130 110 50)
                                :light-ground (blt:rgba 200 180 50)))
#+END_SRC

Now we can update the render-all function to change the tile colors depending on
whether the tile is visible or not:
#+BEGIN_SRC common-lisp
(defun render-all (entities map)
  (blt:clear)
  (dotimes (y *map-height*)
    (dotimes (x *map-width*)
      (let* ((tile (aref (game-map/tiles map) x y))
             (wall (tile/block-sight tile))
             (visible (tile/visible tile)))
        (if visible
            (if wall
                (setf (blt:background-color) (getf *color-map* :light-wall))
                (setf (blt:background-color) (getf *color-map* :light-ground)))
            (if wall
                (setf (blt:background-color) (getf *color-map* :dark-wall))
                (setf (blt:background-color) (getf *color-map* :dark-ground)))))))
  (mapc #'(lambda (entity) (draw entity map)) entities)
  (setf (blt:background-color) (blt:black))
  (blt:refresh))
#+END_SRC

Now if you run the game, you should see something like this:
[[/cl-rltut/display-fov.png]]

*** Exploration
One issue with how this works is the entire map is visible to the player at the
start. We'd rather hide the map, and only start to display it as the player
explores. To do that, we'll add another tile slot to track which tiles have been
explored, and then mark that `t` whenever the tile becomes visible. The
difference between `explored` and `visible` is that once `explored` is set to t,
it will not be reset.
#+BEGIN_SRC common-lisp
(defclass tile ()
  ((blocked :initarg :blocked
            :accessor tile/blocked
            :initform nil)
   (block-sight :initarg :block-sight
                :accessor tile/block-sight
                :initform nil)
   (visible :initarg :visible
            :accessor tile/visible
            :initform nil)
   (explored :initarg :explored
             :accessor tile/explored
             :initform nil)))
#+END_SRC

Now in the fov function, whenever the visible slot is set to true, also set the
explored slot to t:
#+BEGIN_SRC common-lisp
(when (tile/block-sight (aref (game-map/tiles map) tx ty))
  (setf (tile/visible (aref (game-map/tiles map) tx ty)) t
        (tile/explored (aref (game-map/tiles map) tx ty)) t)
  (return))

(setf (tile/visible (aref (game-map/tiles map) tx ty)) t
      (tile/explored (aref (game-map/tiles map) tx ty)) t)
#+END_SRC

With that data being tracked, we can update the renderer to only show visible or
explored tiles.
#+BEGIN_SRC common-lisp
(defun render-all (entities map)
  (blt:clear)
  (dotimes (y *map-height*)
    (dotimes (x *map-width*)
      (let* ((tile (aref (game-map/tiles map) x y))
             (wall (tile/block-sight tile))
             (visible (tile/visible tile))
             (explored (tile/explored tile)))
        (cond (visible
               (if wall
                   (setf (blt:background-color) (getf *color-map* :light-wall))
                   (setf (blt:background-color) (getf *color-map* :light-ground)))
               (setf (blt:cell-char x y) #\Space))
              (explored
               (if wall
                   (setf (blt:background-color) (getf *color-map* :dark-wall))
                   (setf (blt:background-color) (getf *color-map* :dark-ground)))
               (setf (blt:cell-char x y) #\Space))))))
  (mapc #'(lambda (entity) (draw entity map)) entities)
  (setf (blt:background-color) (blt:black))
  (blt:refresh))
#+END_SRC

The last step we'll want to do is to also update the entity draw method. We'll
only want to draw entities that the player can see:
#+BEGIN_SRC common-lisp
(defmethod draw ((e entity) (map game-map))
  (with-slots (x y char color) e
    (if (tile/visible (aref (game-map/tiles map) x y))
        (setf
         (blt:background-color) (blt:cell-background-color x y)
         (blt:color) color
         (blt:cell-char x y) char))))
#+END_SRC

Now if you run the game, you should see something like this:
[[/cl-rltut/dungeon-exploration.gif]]

*** Conclusion
That's all there is to it. If you're interested in other more efficient
algorithms, I'd recommend checking out the [[http://www.roguebasin.com/index.php?title=Category:FOV][FOV section on RogueBasin]].

You can find the current state of the code on [[https://github.com/nwforrer/cl-rltut/tree/part-4][Github]]. The list of changes since
the previous tutorial can be found at
[[https://github.com/nwforrer/cl-rltut/compare/part-3...part-4]].

If you run into any issues, or have questions/feedback, please open an issue on this
blogs [[https://github.com/nwforrer/blog/issues][GitHub repository]].

Continue to [[/posts/roguelike-tutorial-part5][part 5]].
** DONE Roguelike tutorial for Common Lisp - Part 5 - Placing enemies :roguelike:gamedev:lisp:tutorial:
CLOSED: [2019-07-15 Mon 23:19]
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part5
:END:
This tutorial series is based on the [[http://rogueliketutorials.com][Python Roguelike Tutorial]]. This will be
covering [[http://rogueliketutorials.com/tutorials/tcod/part-5/][Part 5]] of that tutorial.

In this post, we'll start adding enemies to the dungeon. We won't be getting
into the combat system yet, but we'll get collision detection and turn-based
movement working.

*** Placing enemies
We'll start by randomly placing enemies during the dungeon generation. Add a
`place-entities` method in the game-map.lisp file:
#+BEGIN_SRC common-lisp
(defun entity-at (entities x y)
  (dolist (entity entities)
    (if (and (= (entity/x entity) x)
             (= (entity/y entity) y))
        (return entity))))

(defmethod place-entities ((map game-map) (room rect) entities max-enemies-per-room)
  (let ((num-monsters (random max-enemies-per-room)))
    (dotimes (monster-index num-monsters)
      (let ((x (+ (random (round (/ (- (rect/x2 room) (rect/x1 room) 1) 2))) (1+ (rect/x1 room))))
            (y (+ (random (round (/ (- (rect/y2 room) (rect/y1 room) 1) 2))) (1+ (rect/y1 room)))))
        (unless (entity-at entities x y)
          (if (< (random 100) 80)
              (nconc entities (list (make-instance 'entity :x x :y y :color (blt:green) :char #\o)))
              (nconc entities (list (make-instance 'entity :x x :y y :color (blt:yellow) :char #\T)))))))))
#+END_SRC
We choose a random number of entities to generate, from 0 up to the
max-enemies-per-room passed in. We then chose a random x and y position, within
the passed in room boundaries. Then, as long as there isn't already an enemy at
the chosen position, we'll place a new enemy. We'll randomly choose between two
different enemies, an orc or a troll. It will be an 80% chance to spawn an Orc,
which will be the weaker enemy.

Call this new method after creating each room in the `make-map` method. The
method will also need to take in two new parameters: the entities list, and the max-enemies-per-room.
#+BEGIN_SRC common-lisp
(defmethod make-map ((map game-map) max-rooms room-min-size room-max-size map-width map-height player entities max-enemies-per-room)
  (do* ((rooms nil)
        (num-rooms 0)
        (room-index 0 (1+ room-index))
        (w (+ (random (- room-max-size room-min-size)) room-min-size)
           (+ (random (- room-max-size room-min-size)) room-min-size))
        (h (+ (random (- room-max-size room-min-size)) room-min-size)
           (+ (random (- room-max-size room-min-size)) room-min-size))
        (x (random (- map-width w))
           (random (- map-width w)))
        (y (random (- map-height h))
           (random (- map-height h)))
        (new-room (make-instance 'rect :x x :y y :w w :h h)
                  (make-instance 'rect :x x :y y :w w :h h))
        (can-place-p t t))
       ((>= room-index max-rooms))
    (dolist (other-room rooms)
      (if (intersect new-room other-room)
          (setf can-place-p nil)))
    (when can-place-p
      (create-room map new-room)
      (multiple-value-bind (new-x new-y) (center new-room)
        (if (zerop num-rooms)
            (setf (entity/x player) new-x
                  (entity/y player) new-y)
            (multiple-value-bind (prev-x prev-y) (center (car (last rooms)))
              (cond ((= (random 2) 1)
                     (create-h-tunnel map prev-x new-x prev-y)
                     (create-v-tunnel map prev-y new-y new-x))
                    (t
                     (create-v-tunnel map prev-y new-y prev-x)
                     (create-h-tunnel map prev-x new-x new-y)))))
        (place-entities map new-room entities max-enemies-per-room)
        (if (null rooms)
            (setf rooms (list new-room))
            (push new-room (cdr (last rooms))))
        (incf num-rooms)))))
#+END_SRC

Since the method signature has been updated, we'll need to update the call from
our main function:
#+BEGIN_SRC common-lisp
(make-map map *max-rooms* *room-min-size* *room-max-size* *map-width* *map-height* player entities *max-enemies-per-room*)
#+END_SRC

The temporary npc we were using before can be deleted now as well.

If you run the game, you should now see enemies spawning in rooms:
[[/cl-rltut/placing-enemies.png]]

*** Colliding with enemies
If you move around in the game now, you'll notice that you can walk right
through the enemies. We'll want to make sure that when you try to walk into
them, you'll collide. Eventually, colliding with enemies should make you attack,
but that will come later. For now, we'll stop the movement and print out a
message.

First, we'll add a `blocks` slot to the entity class. We'll also add a `name`
slot while we're here, which we can use when printing entity information:
#+BEGIN_SRC common-lisp
(defclass entity ()
  ((name :initarg :name :accessor entity/name)
   (x :initarg :x :accessor entity/x)
   (y :initarg :y :accessor entity/y)
   (char :initarg :char :accessor entity/char)
   (color :initarg :color :accessor entity/color)
   (blocks :initarg :blocks :accessor entity/blocks)))
#+END_SRC

Now, update everywhere an entity is created, to supply this additional
information (creating the player, and the enemies)
The player will look like this:
#+BEGIN_SRC common-lisp
(make-instance 'entity
               :name "Player"
               :x (/ *screen-width* 2)
               :y (/ *screen-height* 2)
               :char #\@
               :color (blt:white)
               :blocks t)
#+END_SRC
The enemies will look like this:
#+BEGIN_SRC common-lisp
(make-instance 'entity :name "Orc" :x x :y y :color (blt:green) :char #\o :blocks t)
(make-instance 'entity :name "Troll" :x x :y y :color (blt:yellow) :char #\T :blocks t)
#+END_SRC

We'll need a way to check whether a blocking entity exists in a specific
position on the map. Add a `blocking-entity-at` function, which will return the
entity that is found, or nil otherwise:
#+BEGIN_SRC common-lisp
(defun blocking-entity-at (entities x y)
  (dolist (entity entities)
    (if (and (= (entity/x entity) x)
             (= (entity/y entity) y)
             (entity/blocks entity))
        (return entity))))
#+END_SRC

Now, we can update the player movement code to check for enemy collisions when
moving. To do this, we'll check whether the tile that the player will be moving
to contains a blocking entity. If it does, we won't move the player, and we'll
print out a message instead. Update the movement check in the `game-tick` function:
#+BEGIN_SRC common-lisp
(when move
  (let ((destination-x (+ (entity/x player) (car move)))
        (destination-y (+ (entity/y player) (cdr move))))
    (unless (blocked-p map destination-x destination-y)
      (let ((target (blocking-entity-at entities destination-x destination-y)))
        (cond (target
               (format t "You kick the ~A.~%" (entity/name target)))
              (t
               (move player (car move) (cdr move))
               (fov map (entity/x player) (entity/y player))))))))
#+END_SRC

Now if you run the game, you'll collide with enemies, and see messages printed
out with the name of the entity that you collided with.

*** Taking turns
The final change we'll make in this post is to introduce "turns". Right now, the
player can move whenever they want. However, the game is turn based, so will
need to let the enemies take their turns after the player. To do this, we'll
keep track of whose turn it is (the player or the enemies), and only let them
perform any action if it's their turn.

Add a type definition to hold the various states for the game:
#+BEGIN_SRC common-lisp
(deftype game-states () '(member :player-turn :enemy-turn :exit))
#+END_SRC

Update the `game-tick` function to track and update the game-state. When the
state is `:player-turn`, we'll let the player move and then set the state to
`:enemy-turn`. When the state is `:enemy-turn`, we'll loop through all of the
enemies, and let them take a turn. For now, an enemy will just print something
out when taking a turn, but later on we'll introduce enemy AI. We're also going
to be using the game-state to track when the game will exit, rather than
returning a boolean from the game-tick function.
#+BEGIN_SRC common-lisp
(defun game-tick (player entities map game-state)
  (declare (type game-states game-state))
  (render-all entities map)
  (let* ((action (handle-keys))
         (move (getf action :move))
         (exit (getf action :quit)))
    (when (and move (eql game-state :player-turn))
      (let ((destination-x (+ (entity/x player) (car move)))
            (destination-y (+ (entity/y player) (cdr move))))
        (unless (blocked-p map destination-x destination-y)
          (let ((target (blocking-entity-at entities destination-x destination-y)))
            (cond (target
                   (format t "You kick the ~A.~%" (entity/name target)))
                  (t
                   (move player (car move) (cdr move))
                   (fov map (entity/x player) (entity/y player)))))
          (setf game-state :enemy-turn))))
    (when exit
      (setf game-state :exit)))

  (when (eql game-state :enemy-turn)
    (dolist (entity entities)
      (if (not (eql player entity))
          (format t "The ~A sits idly.~%" (entity/name entity))))
    (setf game-state :player-turn))

  game-state)
#+END_SRC

If you run the game now, when you move, you'll see all enemies that have been
spawned in the dungeon print something out. Each time you move, you'll see the
print statements.

*** Conclusion
That's all there is for now. In the next post we'll be focusing on the combat
system, now that we have enemies to attack.

You can find the current state of the code on [[https://github.com/nwforrer/cl-rltut/tree/part-5][Github]]. The list of changes since
the previous tutorial can be found at
[[https://github.com/nwforrer/cl-rltut/compare/part-4...part-5]].

If you run into any issues, or have questions/feedback, please open an issue on this
blogs [[https://github.com/nwforrer/blog/issues][GitHub repository]].
** TODO Roguelike tutorial for Common Lisp - Part 6 - Combat :roguelike:gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part6
:END:
This tutorial series is based on the [[http://rogueliketutorials.com][Python Roguelike Tutorial]]. This will be
covering [[http://rogueliketutorials.com/tutorials/tcod/part-6/][Part 6]] of that tutorial.

In this part, we will be adding a combat system, allowing players to kill monsters,
as well as be killed. To accomplish this, we will also be adding a component
system, and implementing an A* pathfinding algorithm. This will be a
relatively long post, so let's get right into it.

*** Components
For any enemies that can fight and take damage, we'll be creating a fighter
"component," which will contain the entities hp, attack, and defense. This is
known as "composition," rather than inheritance. In an inheritance model, we
would likely have created a new Fighter class that inherits from the Entity
class. These types of hierarchies can start out fine, but will quickly become
difficult to work with.

Create a new file, components.lisp, with the new component and fighter classes:
#+BEGIN_SRC lisp
(in-package :cl-rltut)

(defclass component ()
  ((owner :initarg :owner :accessor component/owner)))

(defclass fighter (component)
  ((max-hp :initarg :max-hp :accessor fighter/max-hp :initform nil)
   (hp :initarg :hp :accessor fighter/hp)
   (defense :initarg :defense :accessor fighter/defense)
   (power :initarg :power :accessor fighter/power)))
#+END_SRC

We'll also be creating a component to represent an enemies AI behavior, along
with a "take-turn" method to execute the behavior:

#+BEGIN_SRC lisp
(defclass basic-monster (component) ())

(defgeneric take-turn (component))

(defmethod take-turn ((component basic-monster))
  (format t "The ~A wonders when it will get to move." (component/owner component)))
#+END_SRC

New we need to add slots to the "entity" class to hold the two new components.
They will be optional, since not all entities will have the components. We'll
also need to set the "owner" slot on the components to the entity that they are
being attached to, so that the components can get information for their entity,
such as the entity position.

#+BEGIN_SRC lisp -n :hl_lines 8-9, 11-17
(defclass entity ()
  ((name :initarg :name :accessor entity/name)
   (x :initarg :x :accessor entity/x)
   (y :initarg :y :accessor entity/y)
   (char :initarg :char :accessor entity/char)
   (color :initarg :color :accessor entity/color)
   (blocks :initarg :blocks :accessor entity/blocks)
   (fighter :initarg :fighter :accessor entity/fighter :initform nil)
   (ai :initarg :ai :accessor entity/ai :initform nil)))

(defmethod initialize-instance :after ((entity entity) &rest initargs)
  (declare (ignore initargs))
  (with-slots (fighter ai) entity
    (when fighter
      (setf (component/owner fighter) entity))
    (when ai
      (setf (component/owner ai) entity))))
#+END_SRC

Now, when creating the player entity, we'll want to create a fighter component
to add (in the main function in cl-rltut.lisp):
#+BEGIN_SRC lisp -n :hl_lines 2-5,13
...
(let* ((fighter-component (make-instance 'fighter
                                         :hp 30
                                         :defense 2
                                         :power 5))
       (player (make-instance 'entity
                              :name "Player"
                              :x (/ *screen-width* 2)
                              :y (/ *screen-height* 2)
                              :char #\@
                              :color (blt:white)
                              :blocks t
                              :fighter fighter-component))
       (entities (list player))
       (map (make-instance 'game-map :w *map-width* :h *map-height*)))
  ...)
#+END_SRC

And we'll do the same for the monsters (in the place-entities function in
game-map.lisp):
#+BEGIN_SRC lisp -n :hl_lines 8-9,11,14-15,17
(defmethod place-entities ((map game-map) (room rect) entities max-enemies-per-room)
  (let ((num-monsters (random max-enemies-per-room)))
    (dotimes (monster-index num-monsters)
      (let ((x (+ (random (round (/ (- (rect/x2 room) (rect/x1 room) 1) 2))) (1+ (rect/x1 room))))
            (y (+ (random (round (/ (- (rect/y2 room) (rect/y1 room) 1) 2))) (1+ (rect/y1 room)))))
        (unless (entity-at entities x y)
          (cond ((< (random 100) 80)
                 (let* ((fighter-component (make-instance 'fighter :hp 10 :defense 0 :power 3))
                        (ai-component (make-instance 'basic-monster))
                        (orc (make-instance 'entity :name "Orc" :x x :y y :color (blt:green) :char #\o :blocks t
                                                    :fighter fighter-component :ai ai-component)))
                   (nconc entities (list orc))))
                (t
                 (let* ((fighter-component (make-instance 'fighter :hp 16 :defense 1 :power 4))
                        (ai-component (make-instance 'basic-monster))
                        (troll (make-instance 'entity :name "Troll" :x x :y y :color (blt:yellow) :char #\T :blocks t
                                                      :fighter fighter-component :ai ai-component)))
                   (nconc entities (list troll))))))))))
#+END_SRC

Now we can update the game loop to call the take-turn function on all the
entities with the AI component:
#+BEGIN_SRC lisp -n
(when (eql (game-state/state game-state) :enemy-turn)
  (dolist (entity (remove-if-not #'entity/ai entities))
    (take-turn (entity/ai entity)))
  (setf (game-state/state game-state) :player-turn))
#+END_SRC

You can now run the game again. The only difference you'll see is the message
being printed out by the monsters is different, but we've set up a working
component system. Next we'll want to update the AI component to move towards the
player and attack.

*** Basic monster AI
Add a "move-towards" method to the entity class, which will move an the entity
towards a target location. It will only move in a straight line towards the
target, and stop if it hits a wall. We'll add pathfinding a little later.
#+BEGIN_SRC lisp
(defgeneric move-towards (e target-x target-y map entities))

(defmethod move-towards ((e entity) target-x target-y map entities)
  (with-slots (x y) e
    (let* ((dx (- target-x x))
           (dy (- target-y y))
           (distance (sqrt (+ (expt dx 2) (expt dy 2)))))
      (setf dx (round (/ dx distance))
            dy (round (/ dy distance)))
      (unless (or (blocked-p map (+ x dx) (+ y dy))
                  (blocking-entity-at entities (+ x dx) (+ y dy)))
        (move e dx dy)))))

#+END_SRC

Also add a "distance-to" method, which we'll use to decide whether a monster is
close enough to attack the player:
#+BEGIN_SRC lisp
(defmethod distance-to ((e entity) (other entity))
  (let ((dx (- (entity/x other) (entity/x e)))
        (dy (- (entity/y other) (entity/y e))))
    (sqrt (+ (expt dx 2) (expt dy 2)))))
#+END_SRC

Now update the "take-turn" method to move towards the player. We'll move the
monster as long as it's within the FOV of the player. If the monster is one tile
away from the player, then print out an attack message.
#+BEGIN_SRC lisp
(defgeneric take-turn (component target map entities))

(defmethod take-turn ((component basic-monster) target map entities)
  (let* ((monster (component/owner component))
         (in-sight (tile/visible (aref (game-map/tiles map) (entity/x monster) (entity/y monster)))))
    (when in-sight
      (cond ((>= (distance-to monster target) 2)
             (move-towards monster (entity/x target) (entity/y target) map entities))
            ((> (fighter/hp (entity/fighter target)) 0)
             (format t "The ~A insults you! Your ego is damaged!" (entity/name monster)))))))
#+END_SRC

We'll also need to update the call to "take-turn" to pass in the target, map,
and entities parameters.
#+BEGIN_SRC lisp
(when (eql (game-state/state game-state) :enemy-turn)
  (dolist (entity (remove-if-not #'entity/ai entities))
    (take-turn (entity/ai entity) player map entities))
  (setf (game-state/state game-state) :player-turn))
#+END_SRC

Now you can run the game, and the enemies will chase you. When they get close
enough they'll print out a message insulting you.

Currently, the monsters are able to attack the player from a diagonal position,
but the player can only attack up/down/left/right, and both the player and
monsters can only move in four directions. We can either stop the monsters from
attacking diagonally, or allow all entities to attack and move in eight
directions. We'll implement the latter. First, let's allow the player to move in
eight directions. We'll use the "vim keys" for movement. Update the
"handle-keys" function as follows:
#+BEGIN_SRC lisp -n
(defun handle-keys ()
  (when (blt:has-input-p)
    (blt:key-case (blt:read)
                  ((or :up :k) (list :move (cons 0 -1)))
                  ((or :down :j) (list :move (cons 0 1)))
                  ((or :left :h) (list :move (cons -1 0)))
                  ((or :right :l) (list :move (cons 1 0)))
                  (:y (list :move (cons -1 -1)))
                  (:u (list :move (cons 1 -1)))
                  (:b (list :move (cons -1 1)))
                  (:n (list :move (cons 1 1)))
                  (:escape (list :quit t))
                  (:close (list :quit t)))))
#+END_SRC

*** A-star Pathfinding
Now, we'll want to allow the enemies to move in eight directions. To do this,
we'll need to implement a pathfinding algorithm called "A* (A-star)." Red Blob Games
as a great [[https://www.redblobgames.com/pathfinding/a-star/introduction.html][introduction to A*]], as well as an [[https://www.redblobgames.com/pathfinding/a-star/implementation.html][implementation guide]] for
Python, C++, and C#. For my implementation, I used [[https://medium.com/@nicholas.w.swift/easy-a-star-pathfinding-7e6689c7f7b2][this article]] as a guide. I
won't be going very in-depth of how the algorithm works at a high level, so
please refer to the those articles for more information.

First, we're going to use a new library to make use of a priority queue. Update the
dependencies in your ASDF file to match the following:
#+BEGIN_SRC lisp
:depends-on (#:cl-blt #:queues.priority-queue)
#+END_SRC

If you have you're REPl open, go ahead and load the system with Quicklisp:
#+BEGIN_SRC lisp
(ql:quickload :queues.priority-queue)
#+END_SRC

Create a new file "pathfinding.lisp". We'll start by creating a "node" class to
hold the position of the tile, the "parent" (node that we came from to get to
this node), and the g/h/f variables used in the A* algorithm.

- "h" is the estimated distance from the current node to the target location. We
  just calculate the distance between the positions using the Pythagorean
  Theorem, but other estimations could be used instead.
- "g" is the distance from the starting node to the current node. To calculate
  this, we've decided moving left/right/up/down counts as a distance of 10, and
  moving diagonally counts as 14. The "g" for a given node is the sum of all the
  "g" values of the previous nodes it took to get to the current node.
- "f" is the total cost of the node. It's the sum of the "g" and "h" values.

We'll also include some helper functions for the class as well.
=*all-directions*= stores the directions the path can follow from a given tile,
which is in all eight directions.

#+BEGIN_SRC lisp
(in-package #:cl-rltut)

(defparameter *all-directions*
  (list (cons 0 -1)
        (cons 0 1)
        (cons -1 0)
        (cons 1 0)
        (cons -1 -1)
        (cons -1 1)
        (cons 1 -1)
        (cons 1 1)))

(defclass node ()
  ((g :initform 0 :accessor node/g)
   (h :initform 0 :accessor node/h)
   (f :initform 0 :accessor node/f)
   (distance-from-parent :initarg :distance-from-parent :accessor node/distance-from-parent)
   (parent :initarg :parent :initform nil :accessor node/parent)
   (position :initarg :position :initform nil :accessor node/position)))

(defmethod print-object ((obj node) stream)
  (print-unreadable-object (obj stream :type t)
    (with-slots (position parent) obj
      (format stream "~A, parent ~A" position parent))))

(defun node-equal (n1 n2)
  "The two nodes are equal if their position slots are equal."
  (equal (node/position n1) (node/position n2)))

(defun node-compare (n1 n2)
  "Compares the F slots on the node, and returns true if n1's F slot is less than n2's."
  (< (node/f n1) (node/f n2)))

(defun find-in-queue (queue n)
  "Finds the node N in the QUEUE by it's position. If there are multiple nodes
with the same position, it will return the last one it finds."
  (let ((node nil))
    (queues:map-queue #'(lambda (item)
                          (when (node-equal n item)
                            (setf node item)))
                      queue)
    node))
#+END_SRC

Next, we'll write some helper functions to support the A* algorithm. The
documentation on the functions should describe their functionality.

#+BEGIN_SRC lisp
(defun create-path (current-node)
  "Given a node, return a list of all parent nodes leading to it."
  (do ((path nil)
       (current current-node (node/parent current)))
      ((null current) (reverse path))
    (setf path (append path (list (node/position current))))))

(defun make-node (parent-node node-x node-y direction-from-parent)
  "Creates a NODE instance with the given PARENT, NODE-X and NODE-Y, and calculates the
DISTANCE-FROM-PARENT."
  (let ((distance 10))
    (if (and (not (zerop (car direction-from-parent)))
             (not (zerop (cdr direction-from-parent))))
        (setf distance 14))
    (make-instance 'node :parent parent-node
                         :position (cons node-x node-y)
                         :distance-from-parent distance)))

(defun generate-node-cost (child current-node end-node)
  "Calculates and sets the G, H, and F slots on child."
  (with-slots (g h f position distance-from-parent) child
    (setf g (+ distance-from-parent (node/g current-node))
          h (+ (expt (- (car position) (car (node/position end-node))) 2)
               (expt (- (cdr position) (cdr (node/position end-node))) 2))
          f (+ g h))))

(defun update-open-queue (open-list child-node)
  "Updates an existing entry in OPEN-LIST if one exists that both matches CHILD-NODE, and
has a larger G value. If there is no existing entry matching CHILD-NODE, then if pushes
CHILD-NODE onto OPEN-LIST."
  (let ((existing-child (find-in-queue open-list child-node)))
    (cond ((and existing-child (< (node/g child-node) (node/g existing-child)))
           (queues:queue-change open-list
                                (queues:queue-find open-list existing-child)
                                child-node))
          (t
           (queues:qpush open-list child-node)))))

(defun generate-node-children (current-node map open-list closed-list end-node)
  "Generates a list of all valid nodes that can be moved to from CURRENT-NODE,
and adds them to OPEN-QUEUE. A valid node is one that is within the MAP dimensions,
the tile is not blocking, and the node is not on CLOSED-LIST."
  (dolist (new-position *all-directions*)
    (let ((node-x (+ (car (node/position current-node))
                     (car new-position)))
          (node-y (+ (cdr (node/position current-node))
                     (cdr new-position))))
      (unless (or (> node-x (1- (game-map/w map)))
                  (< node-x 0)
                  (> node-y (1- (game-map/h map)))
                  (< node-y 0))
        (unless (tile/blocked (aref (game-map/tiles map) node-x node-y))
          (let ((child (make-node current-node node-x node-y new-position)))
            ;; child is on the closed list
            (unless (find child closed-list :test 'node-equal)
              (generate-node-cost child current-node end-node)
              (update-open-queue open-list child))))))))
#+END_SRC

Now we can write the main function of the algorithm, =astar=. It will start by
creating node instances for the start and end nodes, as well as the open-list
and closed-list. The open-list is initially populated with the start-node as the
first node to check. It will then begin a =do= loop, which pops the next node
off of the open-list queue to process, and continues looping until the path to
the end-node is found, or the open-list queue is empty. The function will return
a list of positions representing the path from start-node to end-node.

#+BEGIN_SRC lisp
(defun astar (map start end)
  "Returns a list of cons cells as a path from the given start to the given end in the given map."
  (let ((start-node (make-instance 'node :position start))
        (end-node (make-instance 'node :position end))
        (open-list (queues:make-queue :priority-queue :compare #'node-compare))
        (closed-list nil))
    (queues:qpush open-list start-node)
    (do ((current-node (queues:qpop open-list) (queues:qpop open-list)))
        ((null current-node))
      (setf closed-list (append closed-list (list current-node)))

      ;; found the goal
      (when (node-equal current-node end-node)
        (return-from astar (create-path current-node)))

      (generate-node-children current-node map open-list closed-list end-node))))
#+END_SRC

To make use of this function, modify the =move-towards= method in entity.lisp
to call =astar= and move to the second position in the returned path (remember
the first position in the path is where the entity is currently at):
#+BEGIN_SRC lisp
(defmethod move-towards ((e entity) target-x target-y map entities)
  (with-slots (x y) e
    (let ((path (astar map (cons x y) (cons target-x target-y))))
      (when path
        (let ((next-location (nth 1 path)))
          (unless (blocking-entity-at entities (car next-location) (cdr next-location))
            (move e (- (car next-location) x) (- (cdr next-location) y))))))))
#+END_SRC

Now if you run the game, you'll see the enemy monsters following the player
around, and that they can now move diagonally.

*** Combat
Next we'll start to implement the cambat system. First, add a =take-damage=
method to the =fighter= class:
#+BEGIN_SRC lisp
(defgeneric take-damage (component amount))

(defmethod take-damage ((component fighter) amount)
  (decf (fighter/hp component) amount))
#+END_SRC

Also add an =attack= method to the =fighter= class. It calculate the damage of
the attack by subtracting the defenders defense value from the attackers power.
If the damage is above zero, then it'll call the =take-damage= function on the defender.
#+BEGIN_SRC lisp
(defgeneric attack (component target))

(defmethod attack ((component fighter) (target entity))
  (let ((damage (- (fighter/power component) (fighter/defense (entity/fighter target)))))
    (cond
      ((> damage 0)
       (take-damage (entity/fighter target) damage))
       (format t "~A attacks ~A for ~A hit points.~%"
               (entity/name (component/owner component))
               (entity/name target)
               damage)
      (t
       (format t "~A attacks ~A but does no damage.~%"
               (entity/name (component/owner component))
               (entity/name target))))))
#+END_SRC

We can now replace the placeholder messages that we were printing before. In the
cl-rltut.lisp files game loop:
#+BEGIN_SRC lisp -n :hl_lines 5
...
(unless (blocked-p map destination-x destination-y)
  (let ((target (blocking-entity-at entities destination-x destination-y)))
    (cond (target
           (attack (entity/fighter player) target))
          (t
           (move player (car move) (cdr move))
           (fov map (entity/x player) (entity/y player)))))
  (setf (game-state/state game-state) :enemy-turn))
#+END_SRC

And the placeholder in components.lisp =take-turn=:
#+BEGIN_SRC lisp -n :hl_lines 8
(defmethod take-turn ((component basic-monster) target map entities)
  (let* ((monster (component/owner component))
         (in-sight (tile/visible (aref (game-map/tiles map) (entity/x monster) (entity/y monster)))))
    (when in-sight
      (cond ((>= (distance-to monster target) 2)
             (move-towards monster (entity/x target) (entity/y target) map entities))
            ((> (fighter/hp (entity/fighter monster)) 0)
             (attack (entity/fighter monster) target))))))
#+END_SRC

*** Conclusion
That's all there is for now. In the next post we'll be focusing on creating the
user interface so that we can display messages within the game, rather than
printing them to the REPL.

You can find the current state of the code on [[https://github.com/nwforrer/cl-rltut/tree/part-6][Github]]. The list of changes since
the previous tutorial can be found at
[[https://github.com/nwforrer/cl-rltut/compare/part-5...part-6]].

If you run into any issues, or have questions/feedback, please open an issue on this
blogs [[https://github.com/nwforrer/blog/issues][GitHub repository]].
** TODO Roguelike tutorial for Common Lisp - Part 7 - Creating the interface :roguelike:gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part7
:END:
** TODO Roguelike tutorial for Common Lisp - Part 8 - Items and inventory :roguelike:gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part8
:END:
** TODO Roguelike tutorial for Common Lisp - Part 9 - Ranged scrolls and targeting :roguelike:gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part9
:END:
** TODO Roguelike tutorial for Common Lisp - Part 10 - Saving and loading :roguelike:gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part10
:END:
** TODO Roguelike tutorial for Common Lisp - Part 11 - Multiple dungeon floors :roguelike:gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part11
:END:
** TODO Roguelike tutorial for Common Lisp - Part 12 - Increasing the difficulty :roguelike:gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part12
:END:
** TODO Roguelike tutorial for Common Lisp - Part 13 - Gearing up :roguelike:gamedev:lisp:tutorial:
:PROPERTIES:
:EXPORT_FILE_NAME: roguelike-tutorial-part13
:END:
